####################
# Integer Overflow #
####################
# Discarded since it is a false positive.
# Fortify cannot verify the origin of the integer, since it was read from a socket.

#[B47863C0CC896E5FE9874624F85B2A80 : high : Integer Overflow : dataflow ]
#libevp-agent/util.c(196) :  ->calloc(1)
#    libevp-agent/sdkrpc/server.c(104) :  ->xcalloc_internal(3)
#    libevp-agent/sdkrpc/server.c(86) : <=> (sz)
#    libevp-agent/sdkrpc/server.c(73) : <- readall(1)
#    libevp-agent/ioutil.c(28) : <- read(1)
B47863C0CC896E5FE9874624F85B2A80

############
# sprintf #
############
# Discarded since changes are not quite impactful, and require upstream merge

#[81192EE135E5C58DAE53A55FEA064011 : critical : STM-117(17th edition)Linux : Using restricted function group 1 : semantic ]
#webclient/webclient.c(1751) : sprintf()
81192EE135E5C58DAE53A55FEA064011

###################################
# Filtering parson related issues #
###################################

# [3E6626898580E0067FAB4A89B46298EB : high : Memory Leak : controlflow ]
#
#     instance_config.c(35) : start -> allocated : <AnonymousObject>.instance = xstrdup_internal(...)
#         util.c(221) : start -> allocated : cp = strdup(...)
#         util.c(221) : allocated -> allocated : cp refers to dynamically allocated memory
#         util.c(222) : Branch not taken: (cp != NULL)
#         util.c(225) : allocated -> allocated : return
#     instance_config.c(35) : allocated -> allocated : <AnonymousObject>.instance refers to dynamically allocated memory
#     instance_config.c(40) : allocated -> allocated : <AnonymousObject>.instance no longer refers to dynamically allocated memory
#     instance_config.c(40) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
3E6626898580E0067FAB4A89B46298EB

# [3033815655637C37ED72F520FFCFE7EC : high : Memory Leak : controlflow ]
#
#     instance_config.c(35) : start -> allocated : <AnonymousObject>.name = xstrdup_internal(...)
#         util.c(221) : start -> allocated : cp = strdup(...)
#         util.c(221) : allocated -> allocated : cp refers to dynamically allocated memory
#         util.c(222) : Branch not taken: (cp != NULL)
#         util.c(225) : allocated -> allocated : return
#     instance_config.c(35) : allocated -> allocated : <AnonymousObject>.name refers to dynamically allocated memory
#     instance_config.c(40) : allocated -> allocated : <AnonymousObject>.name no longer refers to dynamically allocated memory
#     instance_config.c(40) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
3033815655637C37ED72F520FFCFE7EC

# [2B0E380D564F64FF8ABB0409B403730B : high : Memory Leak : controlflow ]
#
#     instance_config.c(35) : start -> allocated : <AnonymousObject>.value = xstrdup_internal(...)
#         util.c(221) : start -> allocated : cp = strdup(...)
#         util.c(221) : allocated -> allocated : cp refers to dynamically allocated memory
#         util.c(222) : Branch not taken: (cp != NULL)
#         util.c(225) : allocated -> allocated : return
#     instance_config.c(35) : allocated -> allocated : <AnonymousObject>.value refers to dynamically allocated memory
#     instance_config.c(40) : allocated -> allocated : <AnonymousObject>.value no longer refers to dynamically allocated memory
#     instance_config.c(40) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
2B0E380D564F64FF8ABB0409B403730B

# A false positive (it is the same path than 255E9D97CF73CCFFECC06F751043AF1F)
#   The object params_v created in mstp_schema.c(67) is freed later.
#   mstp_schema.c(77) params_v assigned -> to a new JSON_Value created by hub_evp2_wrap_rpc_request
#   mstp_schema.c(77) returns v
#   blob_tye_evp_rpc.c(133) v assined to -> calls evp_storagetoken_request_payload_create
#   blob_tye_evp_rpc.c(139) frees v
#
# [60C3C23AF6F0B04CE7D323E516159FE9 : high : Memory Leak : controlflow ]
#
#     hub/hub_tb.c(55) : Branch not taken: (payload != NULL)
#     hub/hub_tb.c(59) : start -> allocated : req = request_alloc()
#         req.c(77) : start -> allocated : req = xmalloc_internal(...)
#             util.c(178) : start -> allocated : vp = malloc(...)
#             util.c(178) : allocated -> allocated : vp refers to dynamically allocated memory
#             util.c(179) : Branch not taken: (vp != NULL)
#             util.c(182) : allocated -> allocated : return
#         req.c(77) : allocated -> allocated : req refers to dynamically allocated memory
#         req.c(91) : allocated -> allocated : return
#     hub/hub_tb.c(59) : allocated -> allocated : req refers to dynamically allocated memory
#     hub/hub_tb.c(63) : allocated -> allocated : request_insert(req)
#         req.c(133) : allocated -> allocated : req refers to dynamically allocated memory
#         req.c(139) : Branch taken: (req->callback == NULL)
#         req.c(141) : Branch taken: (req->payload != NULL)
#         req.c(143) : Branch taken: (req->topic_template != NULL)
#         req.c(145) : Branch taken: (req->priority >= 0)
#         req.c(145) : Branch taken: (req->priority < 2)
#         req.c(149) : Branch not taken: (res != 2)
#         req.c(151) : Branch taken: (res != 0)
#         req.c(152) : allocated -> allocated : return
#     hub/hub_tb.c(63) : Branch not taken: (request_insert(req) == 0)
#     hub/hub_tb.c(67) : allocated -> allocated : req no longer refers to dynamically allocated memory
#     hub/hub_tb.c(67) : allocated -> leak : req end scope : Memory leaked
60C3C23AF6F0B04CE7D323E516159FE9

# False positive. Same as 18D66285AA9FD757CB103B64A60C6DB7.
# [63458BB8A12057731F78A31F71FFBB29 : high : Memory Leak : controlflow ]
#
#     hub/tb/tb.c(488) : start -> allocated : req = request_alloc()
#         req.c(82) : start -> allocated : req = xmalloc_internal(...)
#             util.c(184) : start -> allocated : vp = malloc(...)
#             util.c(184) : allocated -> allocated : vp refers to dynamically allocated memory
#             util.c(185) : Branch not taken: (vp != NULL)
#             util.c(188) : allocated -> allocated : return
#         req.c(82) : allocated -> allocated : req refers to dynamically allocated memory
#         req.c(96) : allocated -> allocated : return
#     hub/tb/tb.c(488) : allocated -> allocated : req refers to dynamically allocated memory
#     hub/tb/tb.c(496) : allocated -> allocated : request_insert(req)
#         req.c(138) : allocated -> allocated : req refers to dynamically allocated memory
#         req.c(144) : Branch taken: (req->callback == NULL)
#         req.c(146) : Branch taken: (req->payload != NULL)
#         req.c(148) : Branch taken: (req->topic_template != NULL)
#         req.c(150) : Branch taken: (req->priority >= 0)
#         req.c(150) : Branch taken: (req->priority < 2)
#         req.c(156) : Branch taken: (res != 0)
#         req.c(157) : allocated -> allocated : return
#     hub/tb/tb.c(496) : Branch not taken: (request_insert(req) == 0)
#     hub/tb/tb.c(499) : allocated -> allocated : req no longer refers to dynamically allocated memory
#     hub/tb/tb.c(499) : allocated -> leak : req end scope : Memory leaked
63458BB8A12057731F78A31F71FFBB29

# False positive. Same as 18D66285AA9FD757CB103B64A60C6DB7.
# [9969557E4403458416C36DDF01674953 : high : Memory Leak : controlflow ]
#
#     hub/tb/tb.c(565) : Branch not taken: (payload != NULL)
#     hub/tb/tb.c(570) : start -> allocated : req = request_alloc()
#         req.c(82) : start -> allocated : req = xmalloc_internal(...)
#             util.c(184) : start -> allocated : vp = malloc(...)
#             util.c(184) : allocated -> allocated : vp refers to dynamically allocated memory
#             util.c(185) : Branch not taken: (vp != NULL)
#             util.c(188) : allocated -> allocated : return
#         req.c(82) : allocated -> allocated : req refers to dynamically allocated memory
#         req.c(96) : allocated -> allocated : return
#     hub/tb/tb.c(570) : allocated -> allocated : req refers to dynamically allocated memory
#     hub/tb/tb.c(586) : allocated -> allocated : request_insert(req)
#         req.c(138) : allocated -> allocated : req refers to dynamically allocated memory
#         req.c(144) : Branch taken: (req->callback == NULL)
#         req.c(146) : Branch taken: (req->payload != NULL)
#         req.c(148) : Branch taken: (req->topic_template != NULL)
#         req.c(150) : Branch taken: (req->priority >= 0)
#         req.c(150) : Branch taken: (req->priority < 2)
#         req.c(156) : Branch taken: (res != 0)
#         req.c(157) : allocated -> allocated : return
#     hub/tb/tb.c(586) : Branch not taken: (ret == 0)
#     hub/tb/tb.c(589) : allocated -> allocated : return
#     hub/tb/tb.c(589) : allocated -> allocated : req no longer refers to dynamically allocated memory
#     hub/tb/tb.c(589) : allocated -> leak : req end scope : Memory leaked
9969557E4403458416C36DDF01674953

# False positive. Same as 18D66285AA9FD757CB103B64A60C6DB7.
# [F4BC0DB59A449AD000146D1FF3F6A717 : high : Memory Leak : controlflow ]
#
#     hub/tb/tb.c(540) : Branch not taken: (payload != NULL)
#     hub/tb/tb.c(545) : start -> allocated : req = request_alloc()
#         req.c(82) : start -> allocated : req = xmalloc_internal(...)
#             util.c(184) : start -> allocated : vp = malloc(...)
#             util.c(184) : allocated -> allocated : vp refers to dynamically allocated memory
#             util.c(185) : Branch not taken: (vp != NULL)
#             util.c(188) : allocated -> allocated : return
#         req.c(82) : allocated -> allocated : req refers to dynamically allocated memory
#         req.c(96) : allocated -> allocated : return
#     hub/tb/tb.c(545) : allocated -> allocated : req refers to dynamically allocated memory
#     hub/tb/tb.c(550) : allocated -> allocated : request_insert(req)
#         req.c(138) : allocated -> allocated : req refers to dynamically allocated memory
#         req.c(144) : Branch taken: (req->callback == NULL)
#         req.c(146) : Branch taken: (req->payload != NULL)
#         req.c(148) : Branch taken: (req->topic_template != NULL)
#         req.c(150) : Branch taken: (req->priority >= 0)
#         req.c(150) : Branch taken: (req->priority < 2)
#         req.c(156) : Branch taken: (res != 0)
#         req.c(157) : allocated -> allocated : return
#     hub/tb/tb.c(550) : Branch not taken: (ret == 0)
#     hub/tb/tb.c(553) : allocated -> allocated : return
#     hub/tb/tb.c(553) : allocated -> allocated : req no longer refers to dynamically allocated memory
#     hub/tb/tb.c(553) : allocated -> leak : req end scope : Memory leaked
F4BC0DB59A449AD000146D1FF3F6A717

# Not an issue. Despite being a signed integer, tmpmax is already checked
# against negative values (zero is also an invalid value in that context)
# and is even tested against SIZE_MAX. After these sanity checks, assigning
# *max to tmpmax is totally safe.
# [EC3A8A0AD55E3A2C4FF67D7A5EB5A853 : high : Type Mismatch : Signed to Unsigned : structural ]
#     req.c(133)
#     ArrayAccess: max [req.c(133)]
#     VariableAccess: tmpmax [req.c(133)]
EC3A8A0AD55E3A2C4FF67D7A5EB5A853

# False positive.
# Yet again, Fortify fails to see the ownership for si is transferred on the
# call to stream_insert when successful, or freed otherwise.
# [9DCB3298A90BBC02F9C3EAB914E75FB3 : high : Memory Leak : controlflow ]
#
#     libevp-agent/stream/stream.c(150) : Branch not taken: (stream_from_name(h, name) == NULL)
#     libevp-agent/stream/stream.c(156) : Branch not taken: (ret == 0)
#     libevp-agent/stream/stream.c(160) : Branch not taken: (stream->type < 3)
#     libevp-agent/stream/stream.c(160) : Branch not taken: (stream->type >= 0)
#     libevp-agent/stream/stream.c(165) : start -> allocated : si = alloc_stream(...)
#         libevp-agent/stream/stream.c(46) : start -> allocated : ret = malloc(...)
#         libevp-agent/stream/stream.c(46) : allocated -> allocated : ret refers to dynamically allocated memory
#         libevp-agent/stream/stream.c(47) : Branch not taken: (ret != NULL)
#         libevp-agent/stream/stream.c(53) : Branch not taken: (stream_duplicate(stream, (&ret->cfg)) == 0)
#         libevp-agent/stream/stream.c(57) : allocated -> allocated : return
#     libevp-agent/stream/stream.c(165) : allocated -> allocated : si refers to dynamically allocated memory
#     libevp-agent/stream/stream.c(166) : Branch not taken: (si != NULL)
#     libevp-agent/stream/stream.c(172) : Branch taken: (si->ops == NULL)
#     libevp-agent/stream/stream.c(174) : goto
#     libevp-agent/stream/stream.c(189) : Branch not taken: (ret == 0)
#     libevp-agent/stream/stream.c(194) : allocated -> allocated : si no longer refers to dynamically allocated memory
#     libevp-agent/stream/stream.c(194) : allocated -> leak : si end scope : Memory leaked
9DCB3298A90BBC02F9C3EAB914E75FB3

# False positive.
# Just like hub_evp1_notify_config where blob is allocated in base64_encode call, the ownership is transferred and blob is
# freed by sdk_free_event when the event has been handled.
# [7599811BD663A07323F7C3B59DB318C6 : high : Memory Leak : controlflow ]
#
#     libevp-agent/instance_config.c(340) : start -> allocated : blob = strdup(...)
#     libevp-agent/instance_config.c(340) : allocated -> allocated : blob refers to dynamically allocated memory
#     libevp-agent/instance_config.c(341) : Branch not taken: (blob != 0)
#     libevp-agent/instance_config.c(347) : allocated -> allocated : module_instance_notify(?, ?, ?, ?, ?, blob, ?)
#         libevp-agent/module_instance.c(898) : allocated -> allocated : blob refers to dynamically allocated memory
#         libevp-agent/module_instance.c(906) : Branch not taken: (m != NULL)
#         libevp-agent/module_instance.c(917) : Branch taken: (type == 1)
#         libevp-agent/module_instance.c(917) : goto
#     libevp-agent/instance_config.c(349) : allocated -> allocated : blob no longer refers to dynamically allocated memory
#     libevp-agent/instance_config.c(349) : allocated -> leak : blob end scope : Memory leaked
7599811BD663A07323F7C3B59DB318C6

##########################################################
# Filtering flatbuffers issues                           #
##########################################################

# [994C38F53DC53FA3194741CAC501D7A2 : high : Integer Overflow : dataflow ]
# sdk_remote.c(567) :  ->malloc(0)
#     sdk_remote.c(562) : <=> (nentries)
#         /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(832) : return
#             /__w/wedge-agent/wedge-agent/include/flatcc/flatcc_endian.h(87) : return
#                 /__w/wedge-agent/wedge-agent/include/flatcc/flatcc_endian.h(87) : return
#                     /usr/include/x86_64-linux-gnu/bits/uintn-identity.h(41) : return (__x)
#                 /__w/wedge-agent/wedge-agent/include/flatcc/flatcc_endian.h(87) : <->__uint32_identity(0->return)
#             /__w/wedge-agent/wedge-agent/include/flatcc/flatcc_endian.h(87) : <->__flatbuffers_uoffset_cast_from_pe(0->return)
#                 /__w/wedge-agent/wedge-agent/include/flatcc/flatcc_endian.h(87) : return (p)
#             /__w/wedge-agent/wedge-agent/include/flatcc/flatcc_endian.h(87) : <->__flatbuffers_uoffset_read(0->return)
#         /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(832) : <->__flatbuffers_uoffset_read_from_pe(0->return)
#     sdk_remote.c(562) : <->EVP_SDK_TelemetryEntry_vec_len(0->return)
#     sdk_remote.c(561) : <=> (vec)
#         /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(848) : return
#         /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(848) : <=> (elem__tmp)
#     sdk_remote.c(561) : <->EVP_SDK_TelemetryInput_entries(0->return)
#     sdk_remote.c(558) : <=> (t)
#         /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(1033) : return
#         /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(1033) : <=> (elem__tmp)
#     sdk_remote.c(558) : <->EVP_SDK_Request_body(0->return)
#     sdk_remote.c(952) :  ->process_send_telemetry(1)
#     sdk_remote.c(909) : <=> (req)
#         /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(1031) : return
#     sdk_remote.c(909) : <->EVP_SDK_Request_as_root(0->return)
#     sdkrpc/server.c(96) :  ->sdk_process_request(0)
#     sdkrpc/server.c(85) : <- readall(1)
#     ioutil.c(22) : <- read(1)
994C38F53DC53FA3194741CAC501D7A2

# [C4E975D3F24A6B555BDF5CAB0D8F241B : high : Integer Overflow : dataflow ]
# sdk_remote.c(504) :  ->calloc(0)
#     sdk_remote.c(501) : <=> (http_ext_request.nheaders)
#         /__w/wedge-agent/wedge-agent/include/sdkenc/flatbuffers_common_reader.h(135) : return
#             /__w/wedge-agent/wedge-agent/include/flatcc/flatcc_endian.h(87) : return
#                 /__w/wedge-agent/wedge-agent/include/flatcc/flatcc_endian.h(87) : return
#                     /usr/include/x86_64-linux-gnu/bits/uintn-identity.h(41) : return (__x)
#                 /__w/wedge-agent/wedge-agent/include/flatcc/flatcc_endian.h(87) : <->__uint32_identity(0->return)
#             /__w/wedge-agent/wedge-agent/include/flatcc/flatcc_endian.h(87) : <->__flatbuffers_uoffset_cast_from_pe(0->return)
#                 /__w/wedge-agent/wedge-agent/include/flatcc/flatcc_endian.h(87) : return (p)
#             /__w/wedge-agent/wedge-agent/include/flatcc/flatcc_endian.h(87) : <->__flatbuffers_uoffset_read(0->return)
#         /__w/wedge-agent/wedge-agent/include/sdkenc/flatbuffers_common_reader.h(135) : <->__flatbuffers_uoffset_read_from_pe(0->return)
#     sdk_remote.c(502) : <->flatbuffers_string_vec_len(0->return)
#     sdk_remote.c(499) : <=> (headers_vec)
#         /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(649) : return
#         /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(649) : <=> (elem__tmp)
#     sdk_remote.c(500) : <->EVP_SDK_BlobRequestHttpExt_headers(0->return)
#     sdk_remote.c(491) : <=> (http_ext)
#         /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(694) : return
#         /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(694) : <=> (elem__tmp)
#     sdk_remote.c(492) : <->EVP_SDK_BlobInput_request(0->return)
#     sdk_remote.c(422) : <=> (blob)
#         /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(1033) : return
#         /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(1033) : <=> (elem__tmp)
#     sdk_remote.c(422) : <->EVP_SDK_Request_body(0->return)
#     sdk_remote.c(952) :  ->process_blob_operation(1)
#     sdk_remote.c(909) : <=> (req)
#         /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(1031) : return
#     sdk_remote.c(909) : <->EVP_SDK_Request_as_root(0->return)
#     sdkrpc/server.c(96) :  ->sdk_process_request(0)
#     sdkrpc/server.c(85) : <- readall(1)
#     ioutil.c(22) : <- read(1)
C4E975D3F24A6B555BDF5CAB0D8F241B

##################
# MQTT-C related #
##################

# It seems Fortify believes that "password" (that is, MQTT password)
# is somehow leaked via our debug logs.
# Strictly speaking, it's true. For example, the password
# can affect the size of the CONNECT control packet (msg->size) and
# thus affects the chance of errors like buffer full. (m->error)
# However, as we don't dump the packet payload including the password
# itself, it isn't a serious security risk as far as I understand.
#
#[E6E579CA422B15654370575FA0377D0E : critical : Privacy Violation : dataflow ]
#xmqtt.c(37) :  ->printf(1)
#    xmqtt.c(79) :  ->mqtt_dump(0->error)
#    xmqtt.c(124) :  ->mqtt_send_check(0->error)
#    evp_agent.c(316) :  ->mqtt_prepare_poll(0->error)
#                MQTT-C/src/mqtt.c(372) : <=> (client->error)
#                MQTT-C/src/mqtt.c(372) : <=> (rv)
#                    MQTT-C/src/mqtt.c(1418) : return
#                    MQTT-C/src/mqtt.c(1390) : <=> (start)
#                MQTT-C/src/mqtt.c(372) : <->mqtt_pack_pubxxx_request(0->return)
#            MQTT-C/src/mqtt.c(817) : <->__mqtt_pubcomp(0->mq.curr->0->error)
#        MQTT-C/src/mqtt.c(70) : <->__mqtt_recv(0->mq.curr->0->error)
#    evp_agent.c(304) : <->mqtt_sync(0->mq.curr->0->error)
#    evp_agent.c(290) : <- mqtt_connect(0->mq.curr)
#            MQTT-C/src/mqtt.c(1768) : <=> (buf)
#        MQTT-C/src/mqtt.c(1218) : <->__mqtt_pack_str(1[]->0)
#    MQTT-C/src/mqtt.c(254) : <->mqtt_pack_connection_request(7[]->0)
#    MQTT-C/src/mqtt.c(254) :  (password)
E6E579CA422B15654370575FA0377D0E

# [F2362E94A2C73399E9F5919CD209B06E : critical : Privacy Violation : dataflow ]
# xmqtt.c(37) :  ->printf(1)
#     xmqtt.c(79) :  ->mqtt_dump(0->error)
#     xmqtt.c(124) :  ->mqtt_send_check(0->error)
#     evp_agent.c(316) :  ->mqtt_prepare_poll(0->error)
#                 MQTT-C/src/mqtt.c(372) : <=> (client->error)
#                 MQTT-C/src/mqtt.c(372) : <=> (rv)
#                     MQTT-C/src/mqtt.c(1418) : return
#                     MQTT-C/src/mqtt.c(1390) : <=> (start)
#                 MQTT-C/src/mqtt.c(372) : <->mqtt_pack_pubxxx_request(0->return)
#             MQTT-C/src/mqtt.c(817) : <->__mqtt_pubcomp(0->mq.curr->0->error)
#         MQTT-C/src/mqtt.c(70) : <->__mqtt_recv(0->mq.curr->0->error)
#     evp_agent.c(304) : <->mqtt_sync(0->mq.curr->0->error)
#     evp_agent.c(290) : <- mqtt_connect(0->mq.curr)
#     MQTT-C/src/mqtt.c(254) : <- mqtt_pack_connection_request(0)
#         MQTT-C/src/mqtt.c(1768) : <=> (buf)
#     MQTT-C/src/mqtt.c(1218) : <->__mqtt_pack_str(1[]->0)
#     MQTT-C/src/mqtt.c(1218) :  (password)
F2362E94A2C73399E9F5919CD209B06E

# recv buffer related issues.
# It seems fortify is unhappy with MQTT-C recv buffer management in general.
# (rather than how we use the library.)
#
#[379ED84381319DEC4704D89DB0B0E7E9 : critical : Buffer Overflow : dataflow ]
# MQTT-C/src/mqtt.c(895) :  ->memmove(2)
#     MQTT-C/src/mqtt.c(894) : <=> (n)
#     MQTT-C/src/mqtt.c(671) : <=> (client->recv_buffer.curr)
#     MQTT-C/src/mqtt.c(664) : <- mqtt_pal_recvall(1)
#     mqtt_pal_custom.c(46) : <- mqtt_pal_tcp_recvall(1)
#     MQTT-C/src/mqtt_pal.c(367) : <- recv(1)
379ED84381319DEC4704D89DB0B0E7E9

#[490AD008AFFAB40DEDEEC84AEDA4D564 : critical : Buffer Overflow : dataflow ]
#MQTT-C/src/mqtt_pal.c(367) :  ->recv(2)
#    mqtt_pal_custom.c(46) :  ->mqtt_pal_tcp_recvall(2)
#    MQTT-C/src/mqtt.c(660) :  ->mqtt_pal_recvall(2)
#    MQTT-C/src/mqtt.c(70) :  ->__mqtt_recv(0->recv_buffer.curr_sz)
#    evp_agent.c(304) :  ->mqtt_sync(0->recv_buffer.curr_sz)
#            MQTT-C/src/mqtt.c(668) : <=> (client->recv_buffer.curr_sz)
#            MQTT-C/src/mqtt.c(660) : <=> (rv)
#                mqtt_pal_custom.c(43) : return
#                    MQTT-C/src/mqtt_pal.c(124) : return
#                    MQTT-C/src/mqtt_pal.c(118) : <=> (buf)
#                mqtt_pal_custom.c(43) : <->mqtt_pal_mbedtls_recvall(1->return)
#            MQTT-C/src/mqtt.c(660) : <->mqtt_pal_recvall(1->return)
#        MQTT-C/src/mqtt.c(70) : <->__mqtt_recv(0->recv_buffer.curr->0->recv_buffer.curr_sz)
#    evp_agent.c(304) : <->mqtt_sync(0->recv_buffer.curr->0->recv_buffer.curr_sz)
#    evp_agent.c(304) : <- mqtt_sync(0->recv_buffer.curr)
#    MQTT-C/src/mqtt.c(70) : <- __mqtt_recv(0->recv_buffer.curr)
#    MQTT-C/src/mqtt.c(660) : <- mqtt_pal_recvall(1)
#    mqtt_pal_custom.c(46) : <- mqtt_pal_tcp_recvall(1)
#    MQTT-C/src/mqtt_pal.c(367) : <- recv(1)
490AD008AFFAB40DEDEEC84AEDA4D564

#[16DEE7AD3F4CAC99B599F04EDFDC2FAB : high : Format String : dataflow ]
#xlog.c(49) :  ->vfprintf(1)
#    xlog.c(198) :  ->vxlog(1)
#    xlog.c(227) :  ->xxlog_vprint(3)
#    evp_agent.c(307) :  ->xxlog_print_abort(4)
#    evp_agent.c(304) : <=> (rc)
#        MQTT-C/src/mqtt.c(71) : return (err)
#        MQTT-C/src/mqtt.c(70) : <=> (err)
#            MQTT-C/src/mqtt.c(665) : return (rv)
#            MQTT-C/src/mqtt.c(660) : <=> (rv)
#                mqtt_pal_custom.c(43) : return
#                    MQTT-C/src/mqtt_pal.c(124) : return
#                    MQTT-C/src/mqtt_pal.c(118) : <=> (buf)
#                mqtt_pal_custom.c(43) : <->mqtt_pal_mbedtls_recvall(1->return)
#            MQTT-C/src/mqtt.c(660) : <->mqtt_pal_recvall(1->return)
#        MQTT-C/src/mqtt.c(70) : <->__mqtt_recv(0->recv_buffer.curr->return)
#    evp_agent.c(304) : <->mqtt_sync(0->recv_buffer.curr->return)
#    MQTT-C/src/mqtt.c(79) :  ->mqtt_reconnect_callback(0->recv_buffer.curr)
#    MQTT-C/src/mqtt.c(70) : <- __mqtt_recv(0->recv_buffer.curr)
#    MQTT-C/src/mqtt.c(660) : <- mqtt_pal_recvall(1)
#    mqtt_pal_custom.c(46) : <- mqtt_pal_tcp_recvall(1)
#    MQTT-C/src/mqtt_pal.c(367) : <- recv(1)
16DEE7AD3F4CAC99B599F04EDFDC2FAB

##########################################################
# Filtering Memory Leak issues                           #
# high : Memory Leak : controlflow                       #
##########################################################

# False positive [impossible branch descision]
# EVP_impl_sendTelemetry returns EVP_TOOBIG (6) in sdk.c(1188)
# So `sdk_local_wasm.c(484) Branch not taken: (0 == ret)` is impossible.
# And in this branch there is the free
#       sdk_local_wasm.c(485) ==> free(entries);
#
# [9D02893B403862FCB5532FF1BD3F5DF5 : high : Memory Leak : controlflow ]
#
#     sdk_local_wasm.c(777) : Branch not taken: (dh == dummy_handle)
#     sdk_local_wasm.c(796) : Branch not taken: (nentries <= 1000)
#     sdk_local_wasm.c(801) : Branch not taken: (wasm_runtime_validate_app_addr(module_inst, entries_addr, (nentries * 8)) != 0)
#     sdk_local_wasm.c(841) : Branch not taken: (g_mqtt_client != NULL)
#     sdk_local_wasm.c(845) : Branch not taken: (xmqtt_request_fits(g_mqtt_client, (totalsz + extra_headers)) != 0)
#     sdk_local_wasm.c(849) : start -> allocated : buf = malloc(...)
#     sdk_local_wasm.c(849) : allocated -> allocated : buf refers to dynamically allocated memory
#     sdk_local_wasm.c(850) : Branch not taken: (buf != NULL)
#     sdk_local_wasm.c(853) : allocated -> allocated : entries refers to dynamically allocated memory
#     sdk_local_wasm.c(879) : Branch not taken: (0 == ret)
#     sdk_local_wasm.c(883) : allocated -> allocated : buf no longer refers to dynamically allocated memory
#     sdk_local_wasm.c(883) : allocated -> allocated : entries no longer refers to dynamically allocated memory
#     sdk_local_wasm.c(883) : allocated -> leak : entries end scope : Memory leaked
9D02893B403862FCB5532FF1BD3F5DF5

# False positive.
# Once again, Fortify fails to see the ownership for `instancedup` is
# transferred to entries[t->n].
# [18571F3EFA94B89D507A610C7450C202 : high : Memory Leak : controlflow ]
#
#     telemetry.c(30) : start -> allocated : instancedup = strdup(...)
#     telemetry.c(30) : allocated -> allocated : instancedup refers to dynamically allocated memory
#     telemetry.c(33) : Branch not taken: (instancedup != 0)
#     telemetry.c(33) : Branch not taken: (topicdup != 0)
#     telemetry.c(33) : Branch not taken: (valuedup != 0)
#     telemetry.c(41) : Branch not taken: (n <= 768614336404564650)
#     telemetry.c(48) : Branch not taken: (entries != 0)
#     telemetry.c(53) : allocated -> allocated : instancedup refers to dynamically allocated memory
#     telemetry.c(60) : allocated -> allocated : return
#     telemetry.c(60) : allocated -> allocated : instancedup no longer refers to dynamically allocated memory
#     telemetry.c(60) : allocated -> allocated : <AnonymousObject>.module_instance no longer refers to dynamically allocated memory
#     telemetry.c(60) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
18571F3EFA94B89D507A610C7450C202

# False positive. Similar to 18571F3EFA94B89D507A610C7450C202.
# [8AA07A32562CD4F7FD6C8EBBEF019BD8 : high : Memory Leak : controlflow ]
#
#     telemetry.c(31) : start -> allocated : topicdup = strdup(...)
#     telemetry.c(31) : allocated -> allocated : topicdup refers to dynamically allocated memory
#     telemetry.c(33) : Branch not taken: (instancedup != 0)
#     telemetry.c(33) : Branch not taken: (topicdup != 0)
#     telemetry.c(33) : Branch not taken: (valuedup != 0)
#     telemetry.c(41) : Branch not taken: (n <= 768614336404564650)
#     telemetry.c(48) : Branch not taken: (entries != 0)
#     telemetry.c(53) : allocated -> allocated : topicdup refers to dynamically allocated memory
#     telemetry.c(60) : allocated -> allocated : return
#     telemetry.c(60) : allocated -> allocated : topicdup no longer refers to dynamically allocated memory
#     telemetry.c(60) : allocated -> allocated : <AnonymousObject>.topic no longer refers to dynamically allocated memory
#     telemetry.c(60) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
8AA07A32562CD4F7FD6C8EBBEF019BD8

# False positive. Similar to 18571F3EFA94B89D507A610C7450C202.
# [E7AC8C4454C9843A06C17CFDE8F45783 : high : Memory Leak : controlflow ]
#
#     telemetry.c(31) : start -> allocated : valuedup = strdup(...)
#     telemetry.c(31) : allocated -> allocated : valuedup refers to dynamically allocated memory
#     telemetry.c(33) : Branch not taken: (instancedup != 0)
#     telemetry.c(33) : Branch not taken: (topicdup != 0)
#     telemetry.c(33) : Branch not taken: (valuedup != 0)
#     telemetry.c(41) : Branch not taken: (n <= 768614336404564650)
#     telemetry.c(48) : Branch not taken: (entries != 0)
#     telemetry.c(53) : allocated -> allocated : valuedup refers to dynamically allocated memory
#     telemetry.c(60) : allocated -> allocated : return
#     telemetry.c(60) : allocated -> allocated : valuedup no longer refers to dynamically allocated memory
#     telemetry.c(60) : allocated -> allocated : <AnonymousObject>.value no longer refers to dynamically allocated memory
#     telemetry.c(60) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
E7AC8C4454C9843A06C17CFDE8F45783

# False positive [impossible branch descision]
# EVP_impl_sendState returns EVP_TOOBIG (6)
# So `sdk_local_wasm.c(484) Branch not taken: (0 == ret)` is impossible.
# And in this branch there is the free
# [B838E55D9366945FE643B14028366303 : high : Memory Leak : controlflow ]
#
#     sdk_local_wasm.c(159) : Branch not taken: (dh == dummy_handle)
#     sdk_local_wasm.c(166) : start -> allocated : rawbuf = malloc(...)
#     sdk_local_wasm.c(166) : allocated -> allocated : rawbuf refers to dynamically allocated memory
#     sdk_local_wasm.c(167) : Branch not taken: (rawbuf != NULL)
#     sdk_local_wasm.c(170) : allocated -> allocated : topic_copy refers to dynamically allocated memory
#     sdk_local_wasm.c(179) : Branch not taken: (ret == 0)
#     sdk_local_wasm.c(183) : allocated -> allocated : rawbuf no longer refers to dynamically allocated memory
#     sdk_local_wasm.c(183) : allocated -> allocated : topic_copy no longer refers to dynamically allocated memory
#     sdk_local_wasm.c(183) : allocated -> leak : topic_copy end scope : Memory leaked
B838E55D9366945FE643B14028366303

# [667342F8A910B2644A59286BFCF2BB1F : high : Memory Leak : controlflow ]
#
#     sdk_local_wasm.c(754) : Branch not taken: (dh == dummy_handle)
#     sdk_local_wasm.c(759) : start -> allocated : rawbuf = malloc(...)
#     sdk_local_wasm.c(759) : allocated -> allocated : rawbuf refers to dynamically allocated memory
#     sdk_local_wasm.c(760) : Branch not taken: (rawbuf != NULL)
#     sdk_local_wasm.c(763) : allocated -> allocated : topic_copy refers to dynamically allocated memory
#     sdk_local_wasm.c(767) : allocated -> allocated : rawbuf no longer refers to dynamically allocated memory
#     sdk_local_wasm.c(767) : allocated -> allocated : topic_copy no longer refers to dynamically allocated memory
#     sdk_local_wasm.c(767) : allocated -> leak : topic_copy end scope : Memory leaked
667342F8A910B2644A59286BFCF2BB1F

# False positive [impossible branch descision] (similar to previous one)
# EVP_impl_sendTelemetry returns EVP_TOOBIG (6) in sdk.c(1188)
# So `sdk_remote.c(488) : Branch not taken: (0 == ret)` is impossible.
# And in this branch there is the free
#       sdk_remote.c(491) ==> free(entries);
#
# [52F5843BA1269E1A5925D903D288954D : high : Memory Leak : controlflow ]
#
#     sdk_remote.c(560) : Branch taken: (t != NULL)
#     sdk_remote.c(566) : start -> allocated : entries = malloc(...)
#     sdk_remote.c(566) : allocated -> allocated : entries refers to dynamically allocated memory
#     sdk_remote.c(568) : Branch not taken: (entries != NULL)
#     sdk_remote.c(587) : Branch not taken: (0 == ret)
#     sdk_remote.c(604) : allocated -> allocated : entries no longer refers to dynamically allocated memory
#     sdk_remote.c(604) : allocated -> leak : entries end scope : Memory leaked
52F5843BA1269E1A5925D903D288954D

# The EVP SDK (agent side) allocates memory for each event (event is any action,
# like RPC, telemetry, ...) and put in queue and wait feedback from the agent.
# At this point Fortify detects a leak.
# But the event and all its allocated fields are freed after the event
# is processed by SDK. Look at sdk_remote.c, after the event is processed
# (sent/receive command/feedback) the method sdk_free_event is called.
# This one frees the allocated fields and the event itself.
# So the all issues related with sdk when a event is enqued is a false positive
# 8 issues 8 type of events (so it matches)
#[753C80AA0C46D7EFF76F1EF35D45EAA6 : high : Memory Leak : controlflow ]
#
#    sdk.c(245) : Branch taken: (h != NULL)
#    sdk.c(245) : Branch taken: (h->exiting == 0)
#    sdk.c(256) : Branch not taken: (event == NULL)
#    sdk.c(260) : start -> allocated : config = xcalloc_internal(...)
#        util.c(188) : start -> allocated : vp = calloc(...)
#        util.c(188) : allocated -> allocated : vp refers to dynamically allocated memory
#        util.c(189) : Branch not taken: (vp != NULL)
#        util.c(192) : allocated -> allocated : return
#    sdk.c(260) : allocated -> allocated : config refers to dynamically allocated memory
#    sdk.c(268) : allocated -> allocated : config no longer refers to dynamically allocated memory
#    sdk.c(268) : allocated -> leak : config end scope : Memory leaked
753C80AA0C46D7EFF76F1EF35D45EAA6

#[7E30001FB07717CFF2FE5B13587B01B0 : high : Memory Leak : controlflow ]
#
#    sdk.c(302) : Branch taken: (h != NULL)
#    sdk.c(302) : Branch taken: (h->exiting == 0)
#    sdk.c(303) : start -> allocated : r = xcalloc_internal(...)
#        util.c(188) : start -> allocated : vp = calloc(...)
#        util.c(188) : allocated -> allocated : vp refers to dynamically allocated memory
#        util.c(189) : Branch not taken: (vp != NULL)
#        util.c(192) : allocated -> allocated : return
#    sdk.c(303) : allocated -> allocated : r refers to dynamically allocated memory
#    sdk.c(310) : allocated -> allocated : r no longer refers to dynamically allocated memory
#    sdk.c(310) : allocated -> leak : r end scope : Memory leaked
7E30001FB07717CFF2FE5B13587B01B0

#[753C80AA0C46D7EFF76F1EF35D45EAA6 : high : Memory Leak : controlflow ]
#
#    sdk.c(245) : Branch taken: (h != NULL)
#    sdk.c(245) : Branch taken: (h->exiting == 0)
#    sdk.c(256) : Branch not taken: (event == NULL)
#    sdk.c(260) : start -> allocated : config = xcalloc_internal(...)
#        util.c(188) : start -> allocated : vp = calloc(...)
#        util.c(188) : allocated -> allocated : vp refers to dynamically allocated memory
#        util.c(189) : Branch not taken: (vp != NULL)
#        util.c(192) : allocated -> allocated : return
#    sdk.c(260) : allocated -> allocated : config refers to dynamically allocated memory
#    sdk.c(268) : allocated -> allocated : config no longer refers to dynamically allocated memory
#    sdk.c(268) : allocated -> leak : config end scope : Memory leaked
753C80AA0C46D7EFF76F1EF35D45EAA6

# False positive. The ownership for instance_name is transferred to the
# caller when successful. Otherwise, the memory is released via free(3).
#[BC68A3AE07F66F3EA7F344AA1CF6B9E1 : high : Memory Leak : controlflow ]
#
#    sdk.c(1351) : start -> allocated : instance_name = strdup(...)
#    sdk.c(1351) : allocated -> allocated : instance_name refers to dynamically allocated memory
#    sdk.c(1353) : Branch taken: (evp_ext->storage_name != NULL)
#    sdk.c(1356) : Branch taken: (storage_name == NULL)
#    sdk.c(1358) : goto
#    sdk.c(1372) : Branch not taken: (ret == 0)
#    sdk.c(1377) : allocated -> allocated : instance_name no longer refers to dynamically allocated memory
#    sdk.c(1377) : allocated -> leak : instance_name end scope : Memory leaked
BC68A3AE07F66F3EA7F344AA1CF6B9E1

# False positive.
#[88FACBFC4F408F7012D2315A7D788BF9 : high : Memory Leak : controlflow ]
#
#    sdk.c(1321) : start -> allocated : remote_name = strdup(...)
#    sdk.c(1321) : allocated -> allocated : remote_name refers to dynamically allocated memory
#    sdk.c(1323) : Branch taken: (instance_name == NULL)
#    sdk.c(1325) : goto
#    sdk.c(1335) : Branch not taken: (ret == 0)
#    sdk.c(1340) : allocated -> allocated : remote_name no longer refers to dynamically allocated memory
#    sdk.c(1340) : allocated -> leak : remote_name end scope : Memory leaked
88FACBFC4F408F7012D2315A7D788BF9

# False positive. Similar to 2875963782EF8F6D3886C98861CEC80A.
#[05D749459E2661F49E9A2800A98323B3 : high : Memory Leak : controlflow ]
#
#    sdk.c(1350) : start -> allocated : remote_name = strdup(...)
#    sdk.c(1350) : allocated -> allocated : remote_name refers to dynamically allocated memory
#    sdk.c(1353) : Branch taken: (evp_ext->storage_name != NULL)
#    sdk.c(1356) : Branch taken: (storage_name == NULL)
#    sdk.c(1358) : goto
#    sdk.c(1372) : Branch not taken: (ret == 0)
#    sdk.c(1377) : allocated -> allocated : remote_name no longer refers to dynamically allocated memory
#    sdk.c(1377) : allocated -> leak : remote_name end scope : Memory leaked
05D749459E2661F49E9A2800A98323B3

#[13DD2A203C18A517C7B4840513317DB0 : high : Memory Leak : controlflow ]
#
#    sdk.c(245) : Branch taken: (h != NULL)
#    sdk.c(245) : Branch taken: (h->exiting == 0)
#    sdk.c(265) : start -> allocated : config->topic = xstrdup_internal(...)
#        util.c(221) : start -> allocated : cp = strdup(...)
#        util.c(221) : allocated -> allocated : cp refers to dynamically allocated memory
#        util.c(222) : Branch not taken: (cp != NULL)
#        util.c(225) : allocated -> allocated : return
#    sdk.c(265) : allocated -> allocated : config->topic refers to dynamically allocated memory
#    sdk.c(268) : allocated -> allocated : config->topic no longer refers to dynamically allocated memory
#    sdk.c(268) : allocated -> leak : config end scope : Memory leaked
13DD2A203C18A517C7B4840513317DB0

#[89E9B42F5C5AF6377B59C48DE9E785F7 : high : Memory Leak : controlflow ]
#
#    sdk.c(1016) : Branch not taken: (g_mqtt_client != NULL)
#    sdk.c(1022) : Branch not taken: (xmqtt_request_fits(g_mqtt_client, len) != 0)
#    sdk.c(1033) : start -> allocated : state = malloc(...)
#    sdk.c(1033) : allocated -> allocated : state refers to dynamically allocated memory
#    sdk.c(1034) : Branch not taken: (state != NULL)
#    sdk.c(1054) : Branch not taken: (oevent == NULL)
#    sdk.c(1082) : Branch not taken: (ret == 0)
#    sdk.c(1085) : allocated -> allocated : state no longer refers to dynamically allocated memory
#    sdk.c(1085) : allocated -> leak : state end scope : Memory leaked
89E9B42F5C5AF6377B59C48DE9E785F7

#[4E89E0F5591AA8A38639E4FE6EB0A8B2 : high : Memory Leak : controlflow ]
#
#    sdk.c(1320) : start -> allocated : instance_name = strdup(...)
#    sdk.c(1320) : allocated -> allocated : instance_name refers to dynamically allocated memory
#    sdk.c(1323) : Branch not taken: (instance_name != NULL)
#    sdk.c(1323) : Branch taken: (remote_name == NULL)
#    sdk.c(1325) : goto
#    sdk.c(1335) : Branch not taken: (ret == 0)
#    sdk.c(1340) : allocated -> allocated : instance_name no longer refers to dynamically allocated memory
#    sdk.c(1340) : allocated -> leak : instance_name end scope : Memory leaked
4E89E0F5591AA8A38639E4FE6EB0A8B2

# False positive
#
# The t->event is inserted to the queue.
# But it is way to abstract `struct sdk_event`
# So t and ->event are the same pointers.
#
# it is freed later in sdk_remote.c:
#   process_get_event method
#       gets each element in the queue
#       cast to specific event.
#       free at the end of each event by sdk_free_event
#[3E1476C1E6658229EE0E5AF63E7786B7 : high : Memory Leak : controlflow ]
#
#    sdk.c(1659) : start -> allocated : event_message = malloc(...)
#    sdk.c(1659) : allocated -> allocated : event_message refers to dynamically allocated memory
#    sdk.c(1661) : Branch not taken: (event_message != NULL)
#    sdk.c(1692) : allocated -> allocated : event_message no longer refers to dynamically allocated memory
#    sdk.c(1692) : allocated -> leak : event_message end scope : Memory leaked
3E1476C1E6658229EE0E5AF63E7786B7

# False positive (idem of previous)
#
# The r->event is inserted to the queue.
# But it is way to abstract `struct sdk_event`
# So r and r->event are the same pointers.
#
# it is freed later in sdk_remote.c:
#   process_get_event method
#       gets each element in the queue
#       cast to specific event.
#       free at the end of each event by sdk_free_event
#[B3B20F3988D18CC8CA5C28514719C705 : high : Memory Leak : controlflow ]
#
#    sdk.c(1721) : Branch not taken: (g_mqtt_client != NULL)
#    sdk.c(1725) : Branch not taken: (xmqtt_request_fits(g_mqtt_client, total_size) != 0)
#    sdk.c(1729) : start -> allocated : t = malloc(...)
#    sdk.c(1729) : allocated -> allocated : t refers to dynamically allocated memory
#    sdk.c(1730) : Branch not taken: (t != NULL)
#    sdk.c(1760) : allocated -> allocated : t no longer refers to dynamically allocated memory
#    sdk.c(1760) : allocated -> leak : t end scope : Memory leaked
B3B20F3988D18CC8CA5C28514719C705

#[D0731D514166A49C8FFB53F1F9FD92A2 : high : Memory Leak : controlflow ]
#
#    sdk.c(1817) : Branch not taken: (response != NULL)
#    sdk.c(1826) : Branch not taken: (g_mqtt_client != NULL)
#    sdk.c(1831) : Branch not taken: (xmqtt_request_fits(g_mqtt_client, outsz) != 0)
#    sdk.c(1835) : start -> allocated : r = malloc(...)
#    sdk.c(1835) : allocated -> allocated : r refers to dynamically allocated memory
#    sdk.c(1836) : Branch not taken: (r != NULL)
#    sdk.c(1864) : allocated -> allocated : r no longer refers to dynamically allocated memory
#    sdk.c(1864) : allocated -> leak : r end scope : Memory leaked
D0731D514166A49C8FFB53F1F9FD92A2

# It is true response might not be a null-terminated string, as it is
# read from user input. However, this same assumption is made in a few
# other places as well.
# [94EC630EB623B72F3F215A46E6DAFC06 : high : String Termination Error : dataflow ]
# sdk.c(1337) :  ->strlen(0)
#     sdk.c(1351) :  ->get_mdc_response_buf_size(3)
#     sdk_remote.c(551) :  ->EVP_impl_sendRpcResponse(3)
#     sdk_remote.c(542) : <=> (response)
#         sdkenc/sdk_reader.h(749) : return
#         sdkenc/sdk_reader.h(749) : <=> (elem__tmp)
#     sdk_remote.c(542) : <->EVP_SDK_RpcResponseInput_response(0->return)
#     sdk_remote.c(538) : <=> (m)
#         sdkenc/sdk_reader.h(894) : return
#         sdkenc/sdk_reader.h(894) : <=> (elem__tmp)
#     sdk_remote.c(538) : <->EVP_SDK_Request_body(0->return)
#     sdk_remote.c(610) :  ->process_send_rpc_response(1)
#     sdk_remote.c(570) : <=> (req)
#         sdkenc/sdk_reader.h(892) : return
#     sdk_remote.c(570) : <->EVP_SDK_Request_as_root(0->return)
#     sdkrpc/server.c(113) :  ->sdk_process_request(0)
#     sdkrpc/server.c(102) : <- readall(1)
#     ioutil.c(32) : <- read(1)
94EC630EB623B72F3F215A46E6DAFC06

# False positive.
# s.name is transferred to stream when the function is succesful.
# Otherwise, it is freed via free_stream.
# [0A6344F4769EBC172A111620056A0739 : high : Memory Leak : controlflow ]
#
#     manifest.c(465) : start -> allocated : s.name = strdup(...)
#     manifest.c(465) : allocated -> allocated : s.name refers to dynamically allocated memory
#     manifest.c(467) : Branch not taken: (s.name != NULL)
#     manifest.c(475) : goto
#     manifest.c(507) : allocated -> allocated : s.name no longer refers to dynamically allocated memory
#     manifest.c(507) : allocated -> leak : s end scope : Memory leaked
0A6344F4769EBC172A111620056A0739

# False positive.
# namedup is transferred to a compound literal, which is then
# transferred to *dst. Otherwise, it is free(3)d.
# [E5BAF7C295BEB651FD2DBB5177CAC5CF : high : Memory Leak : controlflow ]
#
#     libevp-agent/stream/stream.c(472) : start -> allocated : namedup = strdup(...)
#     libevp-agent/stream/stream.c(472) : allocated -> allocated : namedup refers to dynamically allocated memory
#     libevp-agent/stream/stream.c(476) : Branch not taken: (namedup != NULL)
#     libevp-agent/stream/stream.c(484) : Branch taken: (src->type == 0)
#     libevp-agent/stream/stream.c(484) : goto
#     libevp-agent/stream/stream.c(530) : allocated -> allocated : namedup refers to dynamically allocated memory
#     libevp-agent/stream/stream.c(538) : Branch not taken: (ret == 0)
#     libevp-agent/stream/stream.c(543) : allocated -> allocated : namedup no longer refers to dynamically allocated memory
#     libevp-agent/stream/stream.c(543) : allocated -> allocated : <AnonymousObject>.name no longer refers to dynamically allocated memory
#     libevp-agent/stream/stream.c(543) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
#
#     libevp-agent/stream/stream.c(472) : start -> allocated : namedup = strdup(...)
#     libevp-agent/stream/stream.c(472) : allocated -> allocated : namedup refers to dynamically allocated memory
#     libevp-agent/stream/stream.c(476) : Branch not taken: (namedup != NULL)
#     libevp-agent/stream/stream.c(486) : Branch taken: (src->type == 1)
#     libevp-agent/stream/stream.c(486) : goto
#     libevp-agent/stream/stream.c(491) : Branch taken: (connectiondup == NULL)
#     libevp-agent/stream/stream.c(496) : goto
#     libevp-agent/stream/stream.c(538) : Branch not taken: (ret == 0)
#     libevp-agent/stream/stream.c(543) : allocated -> allocated : namedup no longer refers to dynamically allocated memory
#     libevp-agent/stream/stream.c(543) : allocated -> leak : namedup end scope : Memory leaked
E5BAF7C295BEB651FD2DBB5177CAC5CF

# False positive.
# list is transferred to *dst if successful. Otherwise, it is free(3)d.
# [124499A2BD2494F9F09B48FD37DABF50 : high : Memory Leak : controlflow ]
#
#     module_instance.c(426) : start -> allocated : list = malloc(...)
#     module_instance.c(426) : allocated -> allocated : list refers to dynamically allocated memory
#     module_instance.c(428) : Branch not taken: (list != NULL)
#     module_instance.c(433) : Branch taken: (i < src->n)
#     module_instance.c(436) : goto
#     module_instance.c(442) : Branch not taken: (ret == 0)
#     module_instance.c(445) : allocated -> allocated : list no longer refers to dynamically allocated memory
#     module_instance.c(445) : allocated -> leak : list end scope : Memory leaked
124499A2BD2494F9F09B48FD37DABF50

# False positive.
# Fortify fails to see the ownership for event is transferred to the
# TAILQ. It is later freed by sdk_free_event.
# [FAB645EE0389BCEEDFF7466521CF7A24 : high : Memory Leak : controlflow ]
#
#     libevp-agent/stream/stream.c(328) : start -> allocated : args = malloc(...)
#     libevp-agent/stream/stream.c(328) : allocated -> allocated : args refers to dynamically allocated memory
#     libevp-agent/stream/stream.c(329) : Branch not taken: (args != NULL)
#     libevp-agent/stream/stream.c(339) : Branch not taken: (event != NULL)
#     libevp-agent/stream/stream.c(345) : allocated -> allocated : args refers to dynamically allocated memory
#     libevp-agent/stream/stream.c(357) : Branch not taken: (ret == 0)
#     libevp-agent/stream/stream.c(361) : allocated -> allocated : args no longer refers to dynamically allocated memory
#     libevp-agent/stream/stream.c(361) : allocated -> allocated : <AnonymousObject>.free_args no longer refers to dynamically allocated memory
#     libevp-agent/stream/stream.c(361) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
FAB645EE0389BCEEDFF7466521CF7A24

# False positive. Similar to FAB645EE0389BCEEDFF7466521CF7A24.
# [EC095B6EAD3150351E9E6E34CE065126 : high : Memory Leak : controlflow ]
#
#     libevp-agent/stream/stream.c(329) : Branch not taken: (args != NULL)
#     libevp-agent/stream/stream.c(338) : start -> allocated : event = malloc(...)
#     libevp-agent/stream/stream.c(338) : allocated -> allocated : event refers to dynamically allocated memory
#     libevp-agent/stream/stream.c(339) : Branch not taken: (event != NULL)
#     libevp-agent/stream/stream.c(361) : allocated -> allocated : event no longer refers to dynamically allocated memory
#     libevp-agent/stream/stream.c(361) : allocated -> leak : event end scope : Memory leaked
EC095B6EAD3150351E9E6E34CE065126

# False positive.
# Fortify fails to see sem is a semaphore that would block until
# the event is handled (and free(3)d) by the module instance thread.
#[16C3E81F20D2E967B9D97592D8968F69 : high : Memory Leak : controlflow ]
#
#    sdk.c(1099) : Branch not taken: (sem_init((&sem), 0, 0) == 0)
#    sdk.c(1106) : Branch taken: (h->exiting == 0)
#    sdk.c(1107) : start -> allocated : event = malloc(...)
#    sdk.c(1107) : allocated -> allocated : event refers to dynamically allocated memory
#    sdk.c(1109) : Branch not taken: (event != NULL)
#    sdk.c(1133) : allocated -> allocated : event no longer refers to dynamically allocated memory
#    sdk.c(1133) : allocated -> leak : event end scope : Memory leaked
16C3E81F20D2E967B9D97592D8968F69

# IMPORTANT NOTE: This is an actual memory leak (!)
# For implementations using sdk_local_wasm.c, response_copy is never freed.
# However, response_copy is required as, otherwise, response (the original
# string) would be freed at some point by the WASM interpreter.
#
# In order to solve this, EVP_impl_sendRpcResponse must be redesigned so as
# to always duplicate memory and free(3) when no longer needed.
#
# This memory leak shall be solved by future commits. In the meantime, this
# issue is suppressed so as to allow development of other tasks.
#
# [477D8A2A9A35BBE348C16FC0B4265EE9 : high : Memory Leak : controlflow ]
#
#     sdk_local_wasm.c(892) : Branch not taken: (dh == dummy_handle)
#     sdk_local_wasm.c(896) : start -> allocated : response_copy = strdup(...)
#     sdk_local_wasm.c(896) : allocated -> allocated : response_copy refers to dynamically allocated memory
#     sdk_local_wasm.c(897) : Branch not taken: (response_copy != NULL)
#     sdk_local_wasm.c(901) : allocated -> allocated : EVP_impl_sendRpcResponse(?, response_copy, ?, ?, ?, ?, ?)
#         sdk.c(1780) : allocated -> allocated : rawbuf refers to dynamically allocated memory
#         sdk.c(1781) : allocated -> allocated : response refers to dynamically allocated memory
#         sdk.c(1787) : Branch not taken: (response != NULL)
#         sdk.c(1796) : Branch taken: (g_mqtt_client == NULL)
#         sdk.c(1797) : allocated -> allocated : return
#     sdk_local_wasm.c(904) : Branch not taken: (result == 0)
#     sdk_local_wasm.c(907) : allocated -> allocated : response_copy no longer refers to dynamically allocated memory
#     sdk_local_wasm.c(907) : allocated -> leak : response_copy end scope : Memory leaked
477D8A2A9A35BBE348C16FC0B4265EE9

# False positive
# The objects may be removed and freed by subsequent calls but will never be leaked
#
# [1ABC27E1C2366E704CA1B2E0A607C5D5 : high : Memory Leak : controlflow ]
#
#     models/mstp.c(23) : start -> allocated : <AnonymousObject>.headers = xmalloc_internal(...)
#         util.c(178) : start -> allocated : vp = malloc(...)
#         util.c(178) : allocated -> allocated : vp refers to dynamically allocated memory
#         util.c(179) : Branch not taken: (vp != NULL)
#         util.c(182) : allocated -> allocated : return
#     models/mstp.c(23) : allocated -> allocated : <AnonymousObject>.headers refers to dynamically allocated memory
#     models/mstp.c(31) : allocated -> allocated : <AnonymousObject>.headers no longer refers to dynamically allocated memory
#     models/mstp.c(31) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
1ABC27E1C2366E704CA1B2E0A607C5D5

# [81D4BE3F476224B056416E43F7A927F1 : high : Memory Leak : controlflow ]
#
#     models/mstp.c(25) : Branch taken: (error != 0)
#     models/mstp.c(25) : start -> allocated : xstrdup_internal(...)
#         util.c(221) : start -> allocated : cp = strdup(...)
#         util.c(221) : allocated -> allocated : cp refers to dynamically allocated memory
#         util.c(222) : Branch not taken: (cp != NULL)
#         util.c(225) : allocated -> allocated : return
#     models/mstp.c(23) : allocated -> allocated : <AnonymousObject>.error refers to dynamically allocated memory
#     models/mstp.c(26) : Branch taken: (url != 0)
#     models/mstp.c(31) : allocated -> allocated : <AnonymousObject>.error no longer refers to dynamically allocated memory
#     models/mstp.c(31) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
81D4BE3F476224B056416E43F7A927F1

# [25D383F89D0BA43DF42AB8B405502953 : high : Memory Leak : controlflow ]
#
#     models/mstp.c(26) : Branch taken: (url != 0)
#     models/mstp.c(26) : start -> allocated : xstrdup_internal(...)
#         util.c(221) : start -> allocated : cp = strdup(...)
#         util.c(221) : allocated -> allocated : cp refers to dynamically allocated memory
#         util.c(222) : Branch not taken: (cp != NULL)
#         util.c(225) : allocated -> allocated : return
#     models/mstp.c(23) : allocated -> allocated : <AnonymousObject>.url refers to dynamically allocated memory
#     models/mstp.c(31) : allocated -> allocated : <AnonymousObject>.url no longer refers to dynamically allocated memory
#     models/mstp.c(31) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
25D383F89D0BA43DF42AB8B405502953

# False positive
# c8y.c(89) if columns is valid (!NULL) then error is 0
# So the if in line 91 is valid, and the columns is freed in line 94
#
# [D5DDC692344473E0E239F218E33EF21D : high : Memory Leak : controlflow ]
#
#     libevp-agent/blob_type_evp_rpc.c(568) : Branch taken: (wk->type == 3)
#     libevp-agent/blob_type_evp_rpc.c(571) : Branch not taken: (blob_type_evp_load(agent, wk, (&entry)) != 0)
#     libevp-agent/blob_type_evp_rpc.c(583) : start -> allocated : req = request_alloc()
#         libevp-agent/req.c(82) : start -> allocated : req = xmalloc_internal(...)
#             libevp-agent/util.c(184) : start -> allocated : vp = malloc(...)
#             libevp-agent/util.c(184) : allocated -> allocated : vp refers to dynamically allocated memory
#             libevp-agent/util.c(185) : Branch not taken: (vp != NULL)
#             libevp-agent/util.c(188) : allocated -> allocated : return
#         libevp-agent/req.c(82) : allocated -> allocated : req refers to dynamically allocated memory
#         libevp-agent/req.c(96) : allocated -> allocated : return
#     libevp-agent/blob_type_evp_rpc.c(583) : allocated -> allocated : req refers to dynamically allocated memory
#     libevp-agent/blob_type_evp_rpc.c(596) : allocated -> allocated : evp_send_storagetoken_request(?, req, ?)
#         libevp-agent/evp_agent.c(469) : allocated -> allocated : req refers to dynamically allocated memory
#         libevp-agent/evp_agent.c(471) : allocated -> allocated : hub_tb_send_rpc_request(?, req, ?)
#             libevp-agent/hub/hub_tb.c(84) : allocated -> allocated : req refers to dynamically allocated memory
#             libevp-agent/hub/hub_tb.c(90) : allocated -> allocated : request_insert(req)
#                 libevp-agent/req.c(138) : allocated -> allocated : req refers to dynamically allocated memory
#                 libevp-agent/req.c(144) : Branch taken: (req->callback == NULL)
#                 libevp-agent/req.c(146) : Branch taken: (req->payload != NULL)
#                 libevp-agent/req.c(148) : Branch taken: (req->topic_template != NULL)
#                 libevp-agent/req.c(150) : Branch taken: (req->priority >= 0)
#                 libevp-agent/req.c(150) : Branch taken: (req->priority < 2)
#                 libevp-agent/req.c(156) : Branch taken: (res != 0)
#                 libevp-agent/req.c(157) : allocated -> allocated : return
#     libevp-agent/blob_type_evp_rpc.c(596) : Branch not taken: (evp_send_storagetoken_request(agent, req, v) == 0)
#     libevp-agent/blob_type_evp_rpc.c(603) : allocated -> allocated : req no longer refers to dynamically allocated memory
#     libevp-agent/blob_type_evp_rpc.c(603) : allocated -> leak : req end scope : Memory leaked
D5DDC692344473E0E239F218E33EF21D

# The allocated memory (buf) at server.c(76) analysis:
# This issue arises when the callback "fn" is sdk_process_request(...)
# The buffer allocated is passed to sdk_process_request, it checks the type
# of request and processes each type of request with a specific callback.
# Each callback assigns the buffer to event and puts it in the events queue.
# When this queue is processed the event and its fields are freed.
# Code analysis:
# - server.c(88) call sdk_process_request(buf, ...)
# - in case of error the buf is freed
# - sdk_remote.c(579) otherwise, it is processed by different callbacks:
#       - process_get_event (buf -> rawbuf)
#           - sdk_remote.c(295) free rawbuf
#       - process_request_resend_config (buf -> rawbuf)
#           - sdk_remote.c(331) free rawbuf
#       - process_send_state (buf -> rawbuf)
#           - sdk_remote.c(350) EVP_impl_sendState,
#           - sdk.c(713) state->event.buffer = rawbuf;
#           - After the event is enqueued in the events queue
#           - EVP_processEvent process the event and, at the end, frees it
#       - process_blob_operation (buf -> rawbuf)
#           - EVP_impl_blobOperation assigns it to event
#           - The event is enqueued in the events queue (idem as above)
#       - process_send_telemetry (buf -> rawbuf)
#           - EVP_impl_sendTelemetry assigns it to event
#           - The event is enqueued in the events queue (idem as above)
#       - process_send_message (buf -> rawbuf)
#           - EVP_impl_sendMessage assigns it to event
#           - The event is enqueued in the events queue (idem as above)
#       - process_send_rpc_response (buf -> rawbuf)
#           - EVP_impl_sendRpcResponse assigns it to event
#           - The event is enqueued in the events queue (idem as above)
# [9AD20D74459F476EC44B35052092111A : high : Memory Leak : controlflow ]
#
#     sdkrpc/server.c(51) : Branch not taken: (ssz >= 0)
#     sdkrpc/server.c(54) : Branch not taken: (ssz >= 16)
#     sdkrpc/server.c(58) : Branch not taken: (hdr.zero == 0)
#     sdkrpc/server.c(64) : Branch not taken: (sz != 0)
#     sdkrpc/server.c(69) : Branch not taken: (sz <= 131072)
#     sdkrpc/server.c(84) : start -> allocated : buf = xcalloc_internal(...)
#         util.c(188) : start -> allocated : vp = calloc(...)
#         util.c(188) : allocated -> allocated : vp refers to dynamically allocated memory
#         util.c(189) : Branch not taken: (vp != NULL)
#         util.c(192) : allocated -> allocated : return
#     sdkrpc/server.c(84) : allocated -> allocated : buf refers to dynamically allocated memory
#     sdkrpc/server.c(86) : Branch not taken: (ssz >= 0)
#     sdkrpc/server.c(89) : Branch not taken: (ssz >= sz)
#     sdkrpc/server.c(96) : allocated -> allocated : sdk_process_request(buf, ?, ?, ?)
#         sdk_remote.c(899) : allocated -> allocated : buf refers to dynamically allocated memory
#         sdk_remote.c(903) : Branch not taken: (ret == 0)
#         sdk_remote.c(912) : Branch taken: (h != NULL)
#         sdk_remote.c(914) : Branch taken: (req != NULL)
#         sdk_remote.c(924) : goto
#         sdk_remote.c(950) : Branch taken: (fn != NULL)
#         sdk_remote.c(953) : Branch not taken: (error == 0)
#         sdk_remote.c(958) : Branch taken: (resp->buf != NULL)
#         sdk_remote.c(960) : Branch taken: (resp->buflen > 0)
#     sdkrpc/server.c(97) : allocated -> allocated : buf no longer refers to dynamically allocated memory
#     sdkrpc/server.c(97) : allocated -> leak : buf end scope : Memory leaked
9AD20D74459F476EC44B35052092111A

# False positive.
# Yet again, Fortify fails to see the ownership for eventdup is transferred
# to entry->event, which will then free(3) it on notify_free().
# [94637FA846AF053377DDFE701AE8B068 : high : Memory Leak : controlflow ]
#
#     notification.c(39) : Branch not taken: (error == 0)
#     notification.c(45) : start -> allocated : eventdup = strdup(...)
#     notification.c(45) : allocated -> allocated : eventdup refers to dynamically allocated memory
#     notification.c(47) : Branch not taken: (eventdup != NULL)
#     notification.c(55) : Branch not taken: (entry != NULL)
#     notification.c(61) : allocated -> allocated : eventdup refers to dynamically allocated memory
#     notification.c(81) : Branch not taken: (ret == 0)
#     notification.c(86) : allocated -> allocated : eventdup no longer refers to dynamically allocated memory
#     notification.c(86) : allocated -> allocated : <AnonymousObject>.event no longer refers to dynamically allocated memory
#     notification.c(86) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
94637FA846AF053377DDFE701AE8B068

# False positive.
# Fortify fails to understand plat_mod_fs_file_mmap will always set error
# to a non-zero value on failure. Therefore, it is impossible that the goto
# is reached and ret == 0.
# [F7B9BF00CCDD4693ACBA9AC8DE7041AB : high : Memory Leak : controlflow ]
#
#     libevp-agent/module_instance_impl_wasm.c(195) : start -> allocated : handle = plat_mod_fs_file_mmap(...)
#         libevp-agent/platform.c(110) : Branch not taken: (g_platform.mod_fs_file_mmap == 0)
#         libevp-agent/platform.c(119) : Branch not taken: (filename != NULL)
#         libevp-agent/platform.c(126) : Branch not taken: (fd != -1)
#         libevp-agent/platform.c(139) : Branch not taken: (fstat(fd, (&sb)) != -1)
#         libevp-agent/platform.c(149) : Branch not taken: (addr != -1)
#         libevp-agent/platform.c(155) : start -> allocated : handle = malloc(...)
#         libevp-agent/platform.c(155) : allocated -> allocated : handle refers to dynamically allocated memory
#         libevp-agent/platform.c(156) : Branch not taken: (handle != NULL)
#         libevp-agent/platform.c(167) : allocated -> allocated : ret refers to dynamically allocated memory
#         libevp-agent/platform.c(168) : goto
#         libevp-agent/platform.c(183) : allocated -> allocated : return
#     libevp-agent/module_instance_impl_wasm.c(195) : allocated -> allocated : handle refers to dynamically allocated memory
#     libevp-agent/module_instance_impl_wasm.c(197) : Branch not taken: (handle != NULL)
#     libevp-agent/module_instance_impl_wasm.c(197) : Branch taken: (bin == NULL)
#     libevp-agent/module_instance_impl_wasm.c(208) : goto
#     libevp-agent/module_instance_impl_wasm.c(217) : Branch not taken: (ret == 0)
#     libevp-agent/module_instance_impl_wasm.c(225) : allocated -> allocated : handle no longer refers to dynamically allocated memory
#     libevp-agent/module_instance_impl_wasm.c(225) : allocated -> leak : handle end scope : Memory leaked
F7B9BF00CCDD4693ACBA9AC8DE7041AB

# False positive.
# Fortify assumes an impossible condition: the goto cannot be reach while,
# at the same time, ret == 0. OTOH, on success, args is not leaked, but its
# ownership is transferred to the newly created thread.
# [03EBC820D7487B2B32C9D9CDDF7A12EA : high : Memory Leak : controlflow ]
#
#     libevp-agent/module_instance_impl_wasm.c(352) : start -> allocated : args = malloc(...)
#     libevp-agent/module_instance_impl_wasm.c(352) : allocated -> allocated : args refers to dynamically allocated memory
#     libevp-agent/module_instance_impl_wasm.c(354) : Branch not taken: (args != NULL)
#     libevp-agent/module_instance_impl_wasm.c(366) : allocated -> allocated : xpthread_create_with_stack(?, ?, args, ?, ?, ?)
#         libevp-agent/xpthread.c(116) : allocated -> allocated : arg refers to dynamically allocated memory
#         libevp-agent/xpthread.c(123) : Branch taken: (ret != 0)
#         libevp-agent/xpthread.c(125) : goto
#     libevp-agent/module_instance_impl_wasm.c(372) : goto
#     libevp-agent/module_instance_impl_wasm.c(389) : Branch not taken: (ret == 0)
#     libevp-agent/module_instance_impl_wasm.c(394) : allocated -> allocated : args no longer refers to dynamically allocated memory
#     libevp-agent/module_instance_impl_wasm.c(394) : allocated -> leak : args end scope : Memory leaked
03EBC820D7487B2B32C9D9CDDF7A12EA

# False positive.
# Yet again, Fortify fails to see the ownership for s is transferred
# to cfg. It seems like changing to a C99 compound literal triggered
# Fortify, which might be why these issues are becoming more common
# nowadays.
# [71DAA2161694E5EF73722B0A3422F4DE : high : Memory Leak : controlflow ]
#
#     config.c(143) : Branch not taken: (devcfg != 0)
#     config.c(147) : Branch taken: (key == 16)
#     config.c(147) : goto
#     config.c(148) : Branch not taken: (devcfg->registry_auth != 0)
#     config.c(150) : start -> allocated : s = xstrdup_internal(...)
#         util.c(221) : start -> allocated : cp = strdup(...)
#         util.c(221) : allocated -> allocated : cp refers to dynamically allocated memory
#         util.c(222) : Branch not taken: (cp != NULL)
#         util.c(225) : allocated -> allocated : return
#     config.c(150) : allocated -> allocated : s refers to dynamically allocated memory
#     config.c(172) : allocated -> allocated : s refers to dynamically allocated memory
#     config.c(175) : allocated -> allocated : s no longer refers to dynamically allocated memory
#     config.c(175) : allocated -> allocated : <AnonymousObject>.value no longer refers to dynamically allocated memory
#     config.c(175) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
71DAA2161694E5EF73722B0A3422F4DE

# False positive.
# Fortify fails to see that free(3) is assigned to cfg->free, so that, when
# free_config is called, the previously allocated memory shall be free(3)d.
# [976E3854729E9DB6364F475FC61DB9E4 : high : Memory Leak : controlflow ]
#
#     libevp-agent/config.c(201) : start -> allocated : cfg = get_config(...)
#         libevp-agent/config.c(187) : start -> allocated : value = get_config_dynamic(...)
#             libevp-agent/config.c(148) : Branch not taken: (devcfg != 0)
#             libevp-agent/config.c(152) : Branch taken: (key == 16)
#             libevp-agent/config.c(152) : goto
#             libevp-agent/config.c(153) : Branch not taken: (devcfg->registry_auth != 0)
#             libevp-agent/config.c(176) : start -> allocated : cfg = xmalloc_internal(...)
#                 libevp-agent/util.c(184) : start -> allocated : vp = malloc(...)
#                 libevp-agent/util.c(184) : allocated -> allocated : vp refers to dynamically allocated memory
#                 libevp-agent/util.c(185) : Branch not taken: (vp != NULL)
#                 libevp-agent/util.c(188) : allocated -> allocated : return
#             libevp-agent/config.c(176) : allocated -> allocated : cfg refers to dynamically allocated memory
#             libevp-agent/config.c(180) : allocated -> allocated : return
#         libevp-agent/config.c(187) : allocated -> allocated : value refers to dynamically allocated memory
#         libevp-agent/config.c(188) : Branch not taken: (value != NULL)
#         libevp-agent/config.c(190) : allocated -> allocated : return
#     libevp-agent/config.c(201) : allocated -> allocated : cfg refers to dynamically allocated memory
#     libevp-agent/config.c(202) : Branch not taken: (cfg != NULL)
#     libevp-agent/config.c(205) : allocated -> allocated : load_config(cfg, ?, ?)
#         libevp-agent/config.c(48) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(52) : Branch not taken: (config != NULL)
#         libevp-agent/config.c(55) : Branch taken: config_is_pk_file(config->key)
#         libevp-agent/config.c(56) : allocated -> allocated : return
#     libevp-agent/config.c(206) : Branch taken: (rv != 0)
#     libevp-agent/config.c(208) : allocated -> allocated : free_config(cfg)
#         libevp-agent/config.c(123) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(125) : Branch taken: (config != NULL)
#         libevp-agent/config.c(126) : Branch taken: (config->free == NULL)
#         libevp-agent/config.c(127) : allocated -> allocated : return
#     libevp-agent/config.c(209) : allocated -> allocated : return
#     libevp-agent/config.c(209) : allocated -> allocated : cfg no longer refers to dynamically allocated memory
#     libevp-agent/config.c(209) : allocated -> leak : cfg end scope : Memory leaked
976E3854729E9DB6364F475FC61DB9E4

# False positive.
# Similar to 976E3854729E9DB6364F475FC61DB9E4.
# [976E3854729E9DB6364F475FC61DB9E5 : high : Memory Leak : controlflow ]
#
#     libevp-agent/config.c(201) : start -> allocated : cfg = get_config(...)
#         libevp-agent/config.c(187) : start -> allocated : value = get_config_dynamic(...)
#             libevp-agent/config.c(148) : Branch not taken: (devcfg != 0)
#             libevp-agent/config.c(152) : Branch taken: (key == 16)
#             libevp-agent/config.c(152) : goto
#             libevp-agent/config.c(153) : Branch not taken: (devcfg->registry_auth != 0)
#             libevp-agent/config.c(176) : start -> allocated : cfg = xmalloc_internal(...)
#                 libevp-agent/util.c(184) : start -> allocated : vp = malloc(...)
#                 libevp-agent/util.c(184) : allocated -> allocated : vp refers to dynamically allocated memory
#                 libevp-agent/util.c(185) : Branch not taken: (vp != NULL)
#                 libevp-agent/util.c(188) : allocated -> allocated : return
#             libevp-agent/config.c(176) : allocated -> allocated : cfg refers to dynamically allocated memory
#             libevp-agent/config.c(180) : allocated -> allocated : return
#         libevp-agent/config.c(187) : allocated -> allocated : value refers to dynamically allocated memory
#         libevp-agent/config.c(188) : Branch not taken: (value != NULL)
#         libevp-agent/config.c(190) : allocated -> allocated : return
#     libevp-agent/config.c(201) : allocated -> allocated : cfg refers to dynamically allocated memory
#     libevp-agent/config.c(202) : Branch not taken: (cfg != NULL)
#     libevp-agent/config.c(205) : allocated -> allocated : load_config(cfg, ?, ?)
#         libevp-agent/config.c(48) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(52) : Branch not taken: (config != NULL)
#         libevp-agent/config.c(55) : Branch taken: config_is_pk_file(config->key)
#         libevp-agent/config.c(56) : allocated -> allocated : return
#     libevp-agent/config.c(206) : Branch not taken: (rv == 0)
#     libevp-agent/config.c(212) : Branch taken: ((strlen(vp) + 1) == sz)
#     libevp-agent/config.c(214) : allocated -> allocated : free_config(cfg)
#         libevp-agent/config.c(123) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(125) : Branch taken: (config != NULL)
#         libevp-agent/config.c(126) : Branch taken: (config->free == NULL)
#         libevp-agent/config.c(127) : allocated -> allocated : return
#     libevp-agent/config.c(215) : allocated -> allocated : cfg no longer refers to dynamically allocated memory
#     libevp-agent/config.c(215) : allocated -> leak : cfg end scope : Memory leaked
976E3854729E9DB6364F475FC61DB9E5

# False positive.
# Similar to 976E3854729E9DB6364F475FC61DB9E4.
# [266E51DC31C375C04984DE6CE6ABE195 : high : Memory Leak : controlflow ]
#
#     libevp-agent/config.c(227) : start -> allocated : cfg = get_config(...)
#         libevp-agent/config.c(187) : start -> allocated : value = get_config_dynamic(...)
#             libevp-agent/config.c(148) : Branch not taken: (devcfg != 0)
#             libevp-agent/config.c(152) : Branch taken: (key == 16)
#             libevp-agent/config.c(152) : goto
#             libevp-agent/config.c(153) : Branch not taken: (devcfg->registry_auth != 0)
#             libevp-agent/config.c(176) : start -> allocated : cfg = xmalloc_internal(...)
#                 libevp-agent/util.c(184) : start -> allocated : vp = malloc(...)
#                 libevp-agent/util.c(184) : allocated -> allocated : vp refers to dynamically allocated memory
#                 libevp-agent/util.c(185) : Branch not taken: (vp != NULL)
#                 libevp-agent/util.c(188) : allocated -> allocated : return
#             libevp-agent/config.c(176) : allocated -> allocated : cfg refers to dynamically allocated memory
#             libevp-agent/config.c(180) : allocated -> allocated : return
#         libevp-agent/config.c(187) : allocated -> allocated : value refers to dynamically allocated memory
#         libevp-agent/config.c(188) : Branch not taken: (value != NULL)
#         libevp-agent/config.c(190) : allocated -> allocated : return
#     libevp-agent/config.c(227) : allocated -> allocated : cfg refers to dynamically allocated memory
#     libevp-agent/config.c(228) : Branch taken: (cfg != NULL)
#     libevp-agent/config.c(229) : allocated -> allocated : load_config(cfg, ?, ?)
#         libevp-agent/config.c(48) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(52) : Branch not taken: (config != NULL)
#         libevp-agent/config.c(55) : Branch taken: config_is_pk_file(config->key)
#         libevp-agent/config.c(56) : allocated -> allocated : return
#     libevp-agent/config.c(233) : allocated -> allocated : free_config(cfg)
#         libevp-agent/config.c(123) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(125) : Branch taken: (config != NULL)
#         libevp-agent/config.c(126) : Branch taken: (config->free == NULL)
#         libevp-agent/config.c(127) : allocated -> allocated : return
#     libevp-agent/config.c(261) : allocated -> allocated : cfg no longer refers to dynamically allocated memory
#     libevp-agent/config.c(261) : allocated -> leak : cfg end scope : Memory leaked
266E51DC31C375C04984DE6CE6ABE195

# False positive.
# Similar to 976E3854729E9DB6364F475FC61DB9E4.
# [01F902386845E54EDCC067D9081EF339 : high : Memory Leak : controlflow ]
#
#     libevp-agent/tls.c(211) : start -> allocated : cfg = get_config(...)
#         libevp-agent/config.c(187) : start -> allocated : value = get_config_dynamic(...)
#             libevp-agent/config.c(148) : Branch not taken: (devcfg != 0)
#             libevp-agent/config.c(152) : Branch taken: (key == 16)
#             libevp-agent/config.c(152) : goto
#             libevp-agent/config.c(153) : Branch not taken: (devcfg->registry_auth != 0)
#             libevp-agent/config.c(176) : start -> allocated : cfg = xmalloc_internal(...)
#                 libevp-agent/util.c(184) : start -> allocated : vp = malloc(...)
#                 libevp-agent/util.c(184) : allocated -> allocated : vp refers to dynamically allocated memory
#                 libevp-agent/util.c(185) : Branch not taken: (vp != NULL)
#                 libevp-agent/util.c(188) : allocated -> allocated : return
#             libevp-agent/config.c(176) : allocated -> allocated : cfg refers to dynamically allocated memory
#             libevp-agent/config.c(180) : allocated -> allocated : return
#         libevp-agent/config.c(187) : allocated -> allocated : value refers to dynamically allocated memory
#         libevp-agent/config.c(188) : Branch not taken: (value != NULL)
#         libevp-agent/config.c(190) : allocated -> allocated : return
#     libevp-agent/tls.c(211) : allocated -> allocated : cfg refers to dynamically allocated memory
#     libevp-agent/tls.c(211) : Branch not taken: (cfg != NULL)
#     libevp-agent/tls.c(214) : allocated -> allocated : load_config(cfg, ?, ?)
#         libevp-agent/config.c(48) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(52) : Branch not taken: (config != NULL)
#         libevp-agent/config.c(55) : Branch taken: config_is_pk_file(config->key)
#         libevp-agent/config.c(56) : allocated -> allocated : return
#     libevp-agent/tls.c(214) : Branch not taken: (load_config(cfg, (&buf), (&buflen)) == 0)
#     libevp-agent/tls.c(217) : Branch not taken: (crt != NULL)
#     libevp-agent/tls.c(222) : Branch not taken: (rv == 0)
#     libevp-agent/tls.c(225) : allocated -> allocated : unload_config(cfg, ?, ?)
#         libevp-agent/config.c(66) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(68) : Branch not taken: (config != NULL)
#     libevp-agent/tls.c(228) : allocated -> allocated : free_config(cfg)
#         libevp-agent/config.c(123) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(125) : Branch taken: (config != NULL)
#         libevp-agent/config.c(126) : Branch taken: (config->free == NULL)
#         libevp-agent/config.c(127) : allocated -> allocated : return
#     libevp-agent/tls.c(229) : allocated -> allocated : return
#     libevp-agent/tls.c(229) : allocated -> allocated : cfg no longer refers to dynamically allocated memory
#     libevp-agent/tls.c(229) : allocated -> leak : cfg end scope : Memory leaked
01F902386845E54EDCC067D9081EF339

# False positive.
# Similar to 976E3854729E9DB6364F475FC61DB9E4.
# [01F902386845E54EDCC067D9081EF33A : high : Memory Leak : controlflow ]
#
#     libevp-agent/tls.c(211) : start -> allocated : cfg = get_config(...)
#         libevp-agent/config.c(187) : start -> allocated : value = get_config_dynamic(...)
#             libevp-agent/config.c(148) : Branch not taken: (devcfg != 0)
#             libevp-agent/config.c(152) : Branch taken: (key == 16)
#             libevp-agent/config.c(152) : goto
#             libevp-agent/config.c(153) : Branch not taken: (devcfg->registry_auth != 0)
#             libevp-agent/config.c(176) : start -> allocated : cfg = xmalloc_internal(...)
#                 libevp-agent/util.c(184) : start -> allocated : vp = malloc(...)
#                 libevp-agent/util.c(184) : allocated -> allocated : vp refers to dynamically allocated memory
#                 libevp-agent/util.c(185) : Branch not taken: (vp != NULL)
#                 libevp-agent/util.c(188) : allocated -> allocated : return
#             libevp-agent/config.c(176) : allocated -> allocated : cfg refers to dynamically allocated memory
#             libevp-agent/config.c(180) : allocated -> allocated : return
#         libevp-agent/config.c(187) : allocated -> allocated : value refers to dynamically allocated memory
#         libevp-agent/config.c(188) : Branch not taken: (value != NULL)
#         libevp-agent/config.c(190) : allocated -> allocated : return
#     libevp-agent/tls.c(211) : allocated -> allocated : cfg refers to dynamically allocated memory
#     libevp-agent/tls.c(211) : Branch not taken: (cfg != NULL)
#     libevp-agent/tls.c(214) : allocated -> allocated : load_config(cfg, ?, ?)
#         libevp-agent/config.c(48) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(52) : Branch not taken: (config != NULL)
#         libevp-agent/config.c(55) : Branch taken: config_is_pk_file(config->key)
#         libevp-agent/config.c(56) : allocated -> allocated : return
#     libevp-agent/tls.c(214) : Branch taken: (load_config(cfg, (&buf), (&buflen)) != 0)
#     libevp-agent/tls.c(215) : goto
#     libevp-agent/tls.c(237) : allocated -> allocated : free_config(cfg)
#         libevp-agent/config.c(123) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(125) : Branch taken: (config != NULL)
#         libevp-agent/config.c(126) : Branch taken: (config->free == NULL)
#         libevp-agent/config.c(127) : allocated -> allocated : return
#     libevp-agent/tls.c(238) : allocated -> allocated : cfg no longer refers to dynamically allocated memory
#     libevp-agent/tls.c(238) : allocated -> leak : cfg end scope : Memory leaked
01F902386845E54EDCC067D9081EF33A

# False positive.
# Similar to 976E3854729E9DB6364F475FC61DB9E4.
# [C1AF649FEDEB4229BFC18C509C83E7FF : high : Memory Leak : controlflow ]
#
#     libevp-agent/tls.c(299) : start -> allocated : cfg = get_config(...)
#         libevp-agent/config.c(187) : start -> allocated : value = get_config_dynamic(...)
#             libevp-agent/config.c(148) : Branch not taken: (devcfg != 0)
#             libevp-agent/config.c(152) : Branch taken: (key == 16)
#             libevp-agent/config.c(152) : goto
#             libevp-agent/config.c(153) : Branch not taken: (devcfg->registry_auth != 0)
#             libevp-agent/config.c(176) : start -> allocated : cfg = xmalloc_internal(...)
#                 libevp-agent/util.c(184) : start -> allocated : vp = malloc(...)
#                 libevp-agent/util.c(184) : allocated -> allocated : vp refers to dynamically allocated memory
#                 libevp-agent/util.c(185) : Branch not taken: (vp != NULL)
#                 libevp-agent/util.c(188) : allocated -> allocated : return
#             libevp-agent/config.c(176) : allocated -> allocated : cfg refers to dynamically allocated memory
#             libevp-agent/config.c(180) : allocated -> allocated : return
#         libevp-agent/config.c(187) : allocated -> allocated : value refers to dynamically allocated memory
#         libevp-agent/config.c(188) : Branch not taken: (value != NULL)
#         libevp-agent/config.c(190) : allocated -> allocated : return
#     libevp-agent/tls.c(299) : allocated -> allocated : cfg refers to dynamically allocated memory
#     libevp-agent/tls.c(299) : Branch not taken: (cfg != NULL)
#     libevp-agent/tls.c(302) : allocated -> allocated : load_config(cfg, ?, ?)
#         libevp-agent/config.c(48) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(52) : Branch not taken: (config != NULL)
#         libevp-agent/config.c(55) : Branch taken: config_is_pk_file(config->key)
#         libevp-agent/config.c(56) : allocated -> allocated : return
#     libevp-agent/tls.c(302) : Branch not taken: (load_config(cfg, (&buf), (&buflen)) == 0)
#     libevp-agent/tls.c(305) : Branch not taken: (pk != NULL)
#     libevp-agent/tls.c(315) : Branch not taken: (rv == 0)
#     libevp-agent/tls.c(318) : allocated -> allocated : unload_config(cfg, ?, ?)
#         libevp-agent/config.c(66) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(68) : Branch not taken: (config != NULL)
#     libevp-agent/tls.c(321) : allocated -> allocated : free_config(cfg)
#         libevp-agent/config.c(123) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(125) : Branch taken: (config != NULL)
#         libevp-agent/config.c(126) : Branch taken: (config->free == NULL)
#         libevp-agent/config.c(127) : allocated -> allocated : return
#     libevp-agent/tls.c(322) : allocated -> allocated : return
#     libevp-agent/tls.c(322) : allocated -> allocated : cfg no longer refers to dynamically allocated memory
#     libevp-agent/tls.c(322) : allocated -> leak : cfg end scope : Memory leaked
C1AF649FEDEB4229BFC18C509C83E7FF

# False positive.
# Similar to 976E3854729E9DB6364F475FC61DB9E4.
# [C1AF649FEDEB4229BFC18C509C83E800 : high : Memory Leak : controlflow ]
#
#     libevp-agent/tls.c(299) : start -> allocated : cfg = get_config(...)
#         libevp-agent/config.c(187) : start -> allocated : value = get_config_dynamic(...)
#             libevp-agent/config.c(148) : Branch not taken: (devcfg != 0)
#             libevp-agent/config.c(152) : Branch taken: (key == 16)
#             libevp-agent/config.c(152) : goto
#             libevp-agent/config.c(153) : Branch not taken: (devcfg->registry_auth != 0)
#             libevp-agent/config.c(176) : start -> allocated : cfg = xmalloc_internal(...)
#                 libevp-agent/util.c(184) : start -> allocated : vp = malloc(...)
#                 libevp-agent/util.c(184) : allocated -> allocated : vp refers to dynamically allocated memory
#                 libevp-agent/util.c(185) : Branch not taken: (vp != NULL)
#                 libevp-agent/util.c(188) : allocated -> allocated : return
#             libevp-agent/config.c(176) : allocated -> allocated : cfg refers to dynamically allocated memory
#             libevp-agent/config.c(180) : allocated -> allocated : return
#         libevp-agent/config.c(187) : allocated -> allocated : value refers to dynamically allocated memory
#         libevp-agent/config.c(188) : Branch not taken: (value != NULL)
#         libevp-agent/config.c(190) : allocated -> allocated : return
#     libevp-agent/tls.c(299) : allocated -> allocated : cfg refers to dynamically allocated memory
#     libevp-agent/tls.c(299) : Branch not taken: (cfg != NULL)
#     libevp-agent/tls.c(302) : allocated -> allocated : load_config(cfg, ?, ?)
#         libevp-agent/config.c(48) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(52) : Branch not taken: (config != NULL)
#         libevp-agent/config.c(55) : Branch taken: config_is_pk_file(config->key)
#         libevp-agent/config.c(56) : allocated -> allocated : return
#     libevp-agent/tls.c(302) : Branch taken: (load_config(cfg, (&buf), (&buflen)) != 0)
#     libevp-agent/tls.c(303) : goto
#     libevp-agent/tls.c(330) : allocated -> allocated : free_config(cfg)
#         libevp-agent/config.c(123) : allocated -> allocated : config refers to dynamically allocated memory
#         libevp-agent/config.c(125) : Branch taken: (config != NULL)
#         libevp-agent/config.c(126) : Branch taken: (config->free == NULL)
#         libevp-agent/config.c(127) : allocated -> allocated : return
#     libevp-agent/tls.c(331) : allocated -> allocated : cfg no longer refers to dynamically allocated memory
#     libevp-agent/tls.c(331) : allocated -> leak : cfg end scope : Memory leaked
C1AF649FEDEB4229BFC18C509C83E800

# False positive.
# Fortify fails to see that, in case of failure, instance.entryPoint
# is free(3)d by free_module_instance_spec.
# [F99AECBB87090FBF69CAE4BB005C57E2 : high : Memory Leak : controlflow ]
#
#     manifest.c(725) : Branch not taken: (v != NULL)
#     manifest.c(733) : Branch not taken: (o != NULL)
#     manifest.c(733) : Branch not taken: (moduleId != NULL)
#     manifest.c(734) : Branch not taken: (strncmp(name, g_reserved_prefix, strlen(g_reserved_prefix)) != 0)
#     manifest.c(741) : Branch not taken: (entryPoint != NULL)
#     manifest.c(746) : start -> allocated : instance.entryPoint = strdup(...)
#     manifest.c(746) : allocated -> allocated : instance.entryPoint refers to dynamically allocated memory
#     manifest.c(748) : Branch not taken: (instance.entryPoint != NULL)
#     manifest.c(756) : Branch taken: (ret != 0)
#     manifest.c(759) : goto
#     manifest.c(801) : allocated -> allocated : instance.entryPoint no longer refers to dynamically allocated memory
#     manifest.c(801) : allocated -> leak : instance end scope : Memory leaked
#
#     manifest.c(725) : Branch not taken: (v != NULL)
#     manifest.c(733) : Branch not taken: (o != NULL)
#     manifest.c(733) : Branch not taken: (moduleId != NULL)
#     manifest.c(734) : Branch not taken: (strncmp(name, g_reserved_prefix, strlen(g_reserved_prefix)) != 0)
#     manifest.c(741) : Branch not taken: (entryPoint != NULL)
#     manifest.c(746) : start -> allocated : instance.entryPoint = strdup(...)
#     manifest.c(746) : allocated -> allocated : instance.entryPoint refers to dynamically allocated memory
#     manifest.c(748) : Branch not taken: (instance.entryPoint != NULL)
#     manifest.c(756) : Branch not taken: (ret == 0)
#     manifest.c(764) : Branch not taken: (ret == 0)
#     manifest.c(772) : Branch not taken: (instance.name != NULL)
#     manifest.c(780) : Branch not taken: (instance.moduleId != NULL)
#     manifest.c(792) : Branch not taken: (ret == 0)
#     manifest.c(797) : allocated -> allocated : return
#     manifest.c(797) : allocated -> allocated : instance.entryPoint no longer refers to dynamically allocated memory
#     manifest.c(797) : allocated -> leak : instance end scope : Memory leaked
F99AECBB87090FBF69CAE4BB005C57E2

# False positive. Similar to F99AECBB87090FBF69CAE4BB005C57E2.
# [79ED26DD8F3723080A20179B526D8E78 : high : Memory Leak : controlflow ]
#
#     manifest.c(725) : Branch not taken: (v != NULL)
#     manifest.c(733) : Branch not taken: (o != NULL)
#     manifest.c(733) : Branch not taken: (moduleId != NULL)
#     manifest.c(734) : Branch not taken: (strncmp(name, g_reserved_prefix, strlen(g_reserved_prefix)) != 0)
#     manifest.c(741) : Branch not taken: (entryPoint != NULL)
#     manifest.c(748) : Branch not taken: (instance.entryPoint != NULL)
#     manifest.c(756) : Branch not taken: (ret == 0)
#     manifest.c(764) : Branch not taken: (ret == 0)
#     manifest.c(770) : start -> allocated : instance.name = strdup(...)
#     manifest.c(770) : allocated -> allocated : instance.name refers to dynamically allocated memory
#     manifest.c(772) : Branch not taken: (instance.name != NULL)
#     manifest.c(780) : Branch taken: (instance.moduleId == NULL)
#     manifest.c(783) : goto
#     manifest.c(801) : allocated -> allocated : instance.name no longer refers to dynamically allocated memory
#     manifest.c(801) : allocated -> leak : instance end scope : Memory leaked
#
#     manifest.c(725) : Branch not taken: (v != NULL)
#     manifest.c(733) : Branch not taken: (o != NULL)
#     manifest.c(733) : Branch not taken: (moduleId != NULL)
#     manifest.c(734) : Branch not taken: (strncmp(name, g_reserved_prefix, strlen(g_reserved_prefix)) != 0)
#     manifest.c(741) : Branch not taken: (entryPoint != NULL)
#     manifest.c(748) : Branch not taken: (instance.entryPoint != NULL)
#     manifest.c(756) : Branch not taken: (ret == 0)
#     manifest.c(764) : Branch not taken: (ret == 0)
#     manifest.c(770) : start -> allocated : instance.name = strdup(...)
#     manifest.c(770) : allocated -> allocated : instance.name refers to dynamically allocated memory
#     manifest.c(772) : Branch not taken: (instance.name != NULL)
#     manifest.c(780) : Branch not taken: (instance.moduleId != NULL)
#     manifest.c(792) : Branch not taken: (ret == 0)
#     manifest.c(797) : allocated -> allocated : return
#     manifest.c(797) : allocated -> allocated : instance.name no longer refers to dynamically allocated memory
#     manifest.c(797) : allocated -> leak : instance end scope : Memory leaked
79ED26DD8F3723080A20179B526D8E78

# False positive. Similar to F99AECBB87090FBF69CAE4BB005C57E2.
# [556B4D067C64D486F428850F49F2AFF1 : high : Memory Leak : controlflow ]
#
#     manifest.c(725) : Branch not taken: (v != NULL)
#     manifest.c(733) : Branch not taken: (o != NULL)
#     manifest.c(733) : Branch not taken: (moduleId != NULL)
#     manifest.c(734) : Branch not taken: (strncmp(name, g_reserved_prefix, strlen(g_reserved_prefix)) != 0)
#     manifest.c(741) : Branch not taken: (entryPoint != NULL)
#     manifest.c(748) : Branch not taken: (instance.entryPoint != NULL)
#     manifest.c(756) : Branch not taken: (ret == 0)
#     manifest.c(764) : Branch not taken: (ret == 0)
#     manifest.c(772) : Branch not taken: (instance.name != NULL)
#     manifest.c(778) : start -> allocated : instance.moduleId = strdup(...)
#     manifest.c(778) : allocated -> allocated : instance.moduleId refers to dynamically allocated memory
#     manifest.c(780) : Branch not taken: (instance.moduleId != NULL)
#     manifest.c(792) : Branch taken: (ret != 0)
#     manifest.c(793) : goto
#     manifest.c(801) : allocated -> allocated : instance.moduleId no longer refers to dynamically allocated memory
#     manifest.c(801) : allocated -> leak : instance end scope : Memory leaked
#
#     manifest.c(725) : Branch not taken: (v != NULL)
#     manifest.c(733) : Branch not taken: (o != NULL)
#     manifest.c(733) : Branch not taken: (moduleId != NULL)
#     manifest.c(734) : Branch not taken: (strncmp(name, g_reserved_prefix, strlen(g_reserved_prefix)) != 0)
#     manifest.c(741) : Branch not taken: (entryPoint != NULL)
#     manifest.c(748) : Branch not taken: (instance.entryPoint != NULL)
#     manifest.c(756) : Branch not taken: (ret == 0)
#     manifest.c(764) : Branch not taken: (ret == 0)
#     manifest.c(772) : Branch not taken: (instance.name != NULL)
#     manifest.c(778) : start -> allocated : instance.moduleId = strdup(...)
#     manifest.c(778) : allocated -> allocated : instance.moduleId refers to dynamically allocated memory
#     manifest.c(780) : Branch not taken: (instance.moduleId != NULL)
#     manifest.c(792) : Branch not taken: (ret == 0)
#     manifest.c(797) : allocated -> allocated : return
#     manifest.c(797) : allocated -> allocated : instance.moduleId no longer refers to dynamically allocated memory
#     manifest.c(797) : allocated -> leak : instance end scope : Memory leaked
556B4D067C64D486F428850F49F2AFF1

# False positive. Similar to F99AECBB87090FBF69CAE4BB005C57E2.
# [F6C075848518BB810DD22EA06389658F : high : Memory Leak : controlflow ]
#
#     manifest.c(916) : Branch not taken: (o != NULL)
#     manifest.c(916) : Branch not taken: (moduleId != NULL)
#     manifest.c(917) : Branch not taken: (strncmp(name, g_reserved_prefix, strlen(g_reserved_prefix)) != 0)
#     manifest.c(924) : Branch not taken: (entryPoint != NULL)
#     manifest.c(929) : Branch not taken: (strlen(entryPoint) != 0)
#     manifest.c(936) : start -> allocated : instance.entryPoint = strdup(...)
#     manifest.c(936) : allocated -> allocated : instance.entryPoint refers to dynamically allocated memory
#     manifest.c(938) : Branch not taken: (instance.entryPoint != NULL)
#     manifest.c(946) : Branch taken: (ret != 0)
#     manifest.c(949) : goto
#     manifest.c(1002) : allocated -> allocated : instance.entryPoint no longer refers to dynamically allocated memory
#     manifest.c(1002) : allocated -> leak : instance end scope : Memory leaked
#
#     manifest.c(916) : Branch not taken: (o != NULL)
#     manifest.c(916) : Branch not taken: (moduleId != NULL)
#     manifest.c(917) : Branch not taken: (strncmp(name, g_reserved_prefix, strlen(g_reserved_prefix)) != 0)
#     manifest.c(924) : Branch not taken: (entryPoint != NULL)
#     manifest.c(929) : Branch not taken: (strlen(entryPoint) != 0)
#     manifest.c(936) : start -> allocated : instance.entryPoint = strdup(...)
#     manifest.c(936) : allocated -> allocated : instance.entryPoint refers to dynamically allocated memory
#     manifest.c(938) : Branch not taken: (instance.entryPoint != NULL)
#     manifest.c(946) : Branch not taken: (ret == 0)
#     manifest.c(954) : Branch not taken: (ret == 0)
#     manifest.c(962) : Branch not taken: (instance.name != NULL)
#     manifest.c(970) : Branch not taken: (instance.moduleId != NULL)
#     manifest.c(987) : Branch not taken: (streams == NULL)
#     manifest.c(998) : allocated -> allocated : return
#     manifest.c(998) : allocated -> allocated : instance.entryPoint no longer refers to dynamically allocated memory
#     manifest.c(998) : allocated -> leak : instance end scope : Memory leaked
F6C075848518BB810DD22EA06389658F

# False positive. Similar to F99AECBB87090FBF69CAE4BB005C57E2.
# [00C342C2029E138DA2C4C403DD0136D4 : high : Memory Leak : controlflow ]
#
#     manifest.c(916) : Branch not taken: (o != NULL)
#     manifest.c(916) : Branch not taken: (moduleId != NULL)
#     manifest.c(917) : Branch not taken: (strncmp(name, g_reserved_prefix, strlen(g_reserved_prefix)) != 0)
#     manifest.c(924) : Branch not taken: (entryPoint != NULL)
#     manifest.c(929) : Branch not taken: (strlen(entryPoint) != 0)
#     manifest.c(938) : Branch not taken: (instance.entryPoint != NULL)
#     manifest.c(946) : Branch not taken: (ret == 0)
#     manifest.c(954) : Branch not taken: (ret == 0)
#     manifest.c(960) : start -> allocated : instance.name = strdup(...)
#     manifest.c(960) : allocated -> allocated : instance.name refers to dynamically allocated memory
#     manifest.c(962) : Branch not taken: (instance.name != NULL)
#     manifest.c(970) : Branch taken: (instance.moduleId == NULL)
#     manifest.c(973) : goto
#     manifest.c(1002) : allocated -> allocated : instance.name no longer refers to dynamically allocated memory
#     manifest.c(1002) : allocated -> leak : instance end scope : Memory leaked
#
#     manifest.c(916) : Branch not taken: (o != NULL)
#     manifest.c(916) : Branch not taken: (moduleId != NULL)
#     manifest.c(917) : Branch not taken: (strncmp(name, g_reserved_prefix, strlen(g_reserved_prefix)) != 0)
#     manifest.c(924) : Branch not taken: (entryPoint != NULL)
#     manifest.c(929) : Branch not taken: (strlen(entryPoint) != 0)
#     manifest.c(938) : Branch not taken: (instance.entryPoint != NULL)
#     manifest.c(946) : Branch not taken: (ret == 0)
#     manifest.c(954) : Branch not taken: (ret == 0)
#     manifest.c(960) : start -> allocated : instance.name = strdup(...)
#     manifest.c(960) : allocated -> allocated : instance.name refers to dynamically allocated memory
#     manifest.c(962) : Branch not taken: (instance.name != NULL)
#     manifest.c(970) : Branch not taken: (instance.moduleId != NULL)
#     manifest.c(987) : Branch not taken: (streams == NULL)
#     manifest.c(998) : allocated -> allocated : return
#     manifest.c(998) : allocated -> allocated : instance.name no longer refers to dynamically allocated memory
#     manifest.c(998) : allocated -> leak : instance end scope : Memory leaked
00C342C2029E138DA2C4C403DD0136D4

# False positive. Similar to F99AECBB87090FBF69CAE4BB005C57E2.
# [1CE832BFD1FAEC22F58A5C5030F0E9C8 : high : Memory Leak : controlflow ]
#
#     manifest.c(916) : Branch not taken: (o != NULL)
#     manifest.c(916) : Branch not taken: (moduleId != NULL)
#     manifest.c(917) : Branch not taken: (strncmp(name, g_reserved_prefix, strlen(g_reserved_prefix)) != 0)
#     manifest.c(924) : Branch not taken: (entryPoint != NULL)
#     manifest.c(929) : Branch not taken: (strlen(entryPoint) != 0)
#     manifest.c(938) : Branch not taken: (instance.entryPoint != NULL)
#     manifest.c(946) : Branch not taken: (ret == 0)
#     manifest.c(954) : Branch not taken: (ret == 0)
#     manifest.c(962) : Branch not taken: (instance.name != NULL)
#     manifest.c(968) : start -> allocated : instance.moduleId = strdup(...)
#     manifest.c(968) : allocated -> allocated : instance.moduleId refers to dynamically allocated memory
#     manifest.c(970) : Branch not taken: (instance.moduleId != NULL)
#     manifest.c(987) : Branch not taken: (streams == NULL)
#     manifest.c(998) : allocated -> allocated : return
#     manifest.c(998) : allocated -> allocated : instance.moduleId no longer refers to dynamically allocated memory
#     manifest.c(998) : allocated -> leak : instance end scope : Memory leaked
#
#     manifest.c(916) : Branch not taken: (o != NULL)
#     manifest.c(916) : Branch not taken: (moduleId != NULL)
#     manifest.c(917) : Branch not taken: (strncmp(name, g_reserved_prefix, strlen(g_reserved_prefix)) != 0)
#     manifest.c(924) : Branch not taken: (entryPoint != NULL)
#     manifest.c(929) : Branch not taken: (strlen(entryPoint) != 0)
#     manifest.c(938) : Branch not taken: (instance.entryPoint != NULL)
#     manifest.c(946) : Branch not taken: (ret == 0)
#     manifest.c(954) : Branch not taken: (ret == 0)
#     manifest.c(962) : Branch not taken: (instance.name != NULL)
#     manifest.c(968) : start -> allocated : instance.moduleId = strdup(...)
#     manifest.c(968) : allocated -> allocated : instance.moduleId refers to dynamically allocated memory
#     manifest.c(970) : Branch not taken: (instance.moduleId != NULL)
#     manifest.c(987) : Branch taken: (streams != NULL)
#     manifest.c(989) : Branch taken: (ret != 0)
#     manifest.c(991) : goto
#     manifest.c(1002) : allocated -> allocated : instance.moduleId no longer refers to dynamically allocated memory
#     manifest.c(1002) : allocated -> leak : instance end scope : Memory leaked
1CE832BFD1FAEC22F58A5C5030F0E9C8

# False positive.
# Yet again, Fortify fails to see the ownership for `topicdup` is transferred
# to the compound literal in `msg`, or `free(3)`d otherwise.
# [1B37D1F23E1F111DFE133BD610BF61E3 : high : Memory Leak : controlflow ]
#
#     sys/sys_notify_config.c(71) : Branch not taken: (stype != 2)
#     sys/sys_notify_config.c(76) : Branch not taken: (cfg->type == 2)
#     sys/sys_notify_config.c(84) : start -> allocated : topicdup = strdup(...)
#     sys/sys_notify_config.c(84) : allocated -> allocated : topicdup refers to dynamically allocated memory
#     sys/sys_notify_config.c(84) : Branch not taken: (topicdup != NULL)
#     sys/sys_notify_config.c(89) : Branch not taken: (valuedup != NULL)
#     sys/sys_notify_config.c(94) : Branch not taken: (cl != NULL)
#     sys/sys_notify_config.c(99) : allocated -> allocated : topicdup refers to dynamically allocated memory
#     sys/sys_notify_config.c(110) : Branch not taken: (chan_send(cfg->c->ch, (&msg)) != 0)
#     sys/sys_notify_config.c(116) : allocated -> allocated : return
#     sys/sys_notify_config.c(116) : allocated -> allocated : topicdup no longer refers to dynamically allocated memory
#     sys/sys_notify_config.c(116) : allocated -> allocated : <AnonymousObject>.topic no longer refers to dynamically allocated memory
#     sys/sys_notify_config.c(116) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
1B37D1F23E1F111DFE133BD610BF61E3

# Yet again, Fortify fails to see the ownership for `cmd` is tranferred to
# string_map_insert.
# [E413FD6DF91306EB47ECB73B8614D5F6 : high : Memory Leak : controlflow ]
#
#     sys/SYS_register_command_cb.c(31) : start -> allocated : cmd = malloc(...)
#     sys/SYS_register_command_cb.c(31) : allocated -> allocated : cmd refers to dynamically allocated memory
#     sys/SYS_register_command_cb.c(31) : Branch not taken: (cmd != 0)
#     sys/SYS_register_command_cb.c(38) : Branch not taken: (string_map_insert(gr->ddc_map, p->command, cmd, (0 != 0)) == 0)
#     sys/SYS_register_command_cb.c(51) : allocated -> allocated : cmd no longer refers to dynamically allocated memory
#     sys/SYS_register_command_cb.c(51) : allocated -> leak : cmd end scope : Memory leaked
E413FD6DF91306EB47ECB73B8614D5F6

# False positive. Similar to E413FD6DF91306EB47ECB73B8614D5F6.
# [4272516430F6E72124EC06FF972B0004 : high : Memory Leak : controlflow ]
#
#     sys/SYS_register_command_cb.c(58) : start -> allocated : namedup = strdup(...)
#     sys/SYS_register_command_cb.c(58) : allocated -> allocated : namedup refers to dynamically allocated memory
#     sys/SYS_register_command_cb.c(60) : Branch not taken: (namedup != 0)
#     sys/SYS_register_command_cb.c(66) : allocated -> allocated : namedup refers to dynamically allocated memory
#     sys/SYS_register_command_cb.c(74) : Branch not taken: (chan_send(c->gr->ch, (&msg)) != 0)
#     sys/SYS_register_command_cb.c(79) : allocated -> allocated : namedup no longer refers to dynamically allocated memory
#     sys/SYS_register_command_cb.c(79) : allocated -> allocated : <AnonymousObject>.command no longer refers to dynamically allocated memory
#     sys/SYS_register_command_cb.c(79) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
4272516430F6E72124EC06FF972B0004

# False positive.
# Yet again, Fortify fails to see the ownership for `rdup`
# is transferred to `r`, and `free(3)`d otherwise.
# [A64592A57013C5B37E6398DEF15FF806 : high : Memory Leak : controlflow ]
#
#     sys/SYS_set_response_cb.c(46) : start -> allocated : rdup = plat_mod_mem_mng_strdup(...)
#         platform.c(485) : Branch not taken: (g_platform.mod_mem_mng_strdup == 0)
#         platform.c(488) : start -> allocated : strdup(...)
#         platform.c(488) : allocated -> allocated : return
#     sys/SYS_set_response_cb.c(46) : allocated -> allocated : rdup refers to dynamically allocated memory
#     sys/SYS_set_response_cb.c(48) : Branch not taken: (rdup != 0)
#     sys/SYS_set_response_cb.c(55) : Branch not taken: (r != 0)
#     sys/SYS_set_response_cb.c(60) : allocated -> allocated : rdup refers to dynamically allocated memory
#     sys/SYS_set_response_cb.c(77) : Branch not taken: (chan_send(c->gr->ch, (&msg)) != 0)
#     sys/SYS_set_response_cb.c(83) : allocated -> allocated : return
#     sys/SYS_set_response_cb.c(83) : allocated -> allocated : rdup no longer refers to dynamically allocated memory
#     sys/SYS_set_response_cb.c(83) : allocated -> allocated : <AnonymousObject>.response no longer refers to dynamically allocated memory
#     sys/SYS_set_response_cb.c(83) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
A64592A57013C5B37E6398DEF15FF806

# False positive.
# Yet again, Fortify fails to see the ownership for `r`
# is transferred to `msg`, and `free(3)`d otherwise.
# [C66CC8EA77D377722F7345429235E628 : high : Memory Leak : controlflow ]
#
#     sys/SYS_set_response_cb.c(51) : Branch not taken: (rdup != 0)
#     sys/SYS_set_response_cb.c(56) : start -> allocated : r = malloc(...)
#     sys/SYS_set_response_cb.c(56) : allocated -> allocated : r refers to dynamically allocated memory
#     sys/SYS_set_response_cb.c(58) : Branch not taken: (r != 0)
#     sys/SYS_set_response_cb.c(72) : allocated -> allocated : r refers to dynamically allocated memory
#     sys/SYS_set_response_cb.c(78) : Branch not taken: (chan_send(c->gr->ch, (&msg)) != 0)
#     sys/SYS_set_response_cb.c(84) : allocated -> allocated : return
#     sys/SYS_set_response_cb.c(84) : allocated -> allocated : r no longer refers to dynamically allocated memory
#     sys/SYS_set_response_cb.c(84) : allocated -> allocated : msg.param no longer refers to dynamically allocated memory
#     sys/SYS_set_response_cb.c(84) : allocated -> leak : msg end scope : Memory leaked
C66CC8EA77D377722F7345429235E628

# False positive. Similar to 68D3603812351F2CC3E2F1BB2E178B44.
# [E4A2206F74D5E0437C1D5BF2CD542262 : high : Memory Leak : controlflow ]
#
#     sys/sys_notify_ddc.c(49) : Branch not taken: (cmd != 0)
#     sys/sys_notify_ddc.c(54) : start -> allocated : paramsdup = strdup(...)
#     sys/sys_notify_ddc.c(54) : allocated -> allocated : paramsdup refers to dynamically allocated memory
#     sys/sys_notify_ddc.c(54) : Branch not taken: (paramsdup != 0)
#     sys/sys_notify_ddc.c(59) : Branch not taken: (cl != NULL)
#     sys/sys_notify_ddc.c(64) : allocated -> allocated : paramsdup refers to dynamically allocated memory
#     sys/sys_notify_ddc.c(75) : Branch not taken: (chan_send(cmd->c->ch, (&msg)) != 0)
#     sys/sys_notify_ddc.c(80) : allocated -> allocated : return
#     sys/sys_notify_ddc.c(80) : allocated -> allocated : paramsdup no longer refers to dynamically allocated memory
#     sys/sys_notify_ddc.c(80) : allocated -> allocated : <AnonymousObject>.params no longer refers to dynamically allocated memory
#     sys/sys_notify_ddc.c(80) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
E4A2206F74D5E0437C1D5BF2CD542262

# False positive. Similar to C66CC8EA77D377722F7345429235E628.
# [19F501BBF5433647E1F3365D71F7959F : high : Memory Leak : controlflow ]
#
#     sys/sys_notify_ddc.c(49) : Branch not taken: (cmd != 0)
#     sys/sys_notify_ddc.c(54) : Branch not taken: (paramsdup != 0)
#     sys/sys_notify_ddc.c(59) : start -> allocated : cl = malloc(...)
#     sys/sys_notify_ddc.c(59) : allocated -> allocated : cl refers to dynamically allocated memory
#     sys/sys_notify_ddc.c(59) : Branch not taken: (cl != NULL)
#     sys/sys_notify_ddc.c(70) : allocated -> allocated : cl refers to dynamically allocated memory
#     sys/sys_notify_ddc.c(75) : Branch not taken: (chan_send(cmd->c->ch, (&msg)) != 0)
#     sys/sys_notify_ddc.c(80) : allocated -> allocated : return
#     sys/sys_notify_ddc.c(80) : allocated -> allocated : cl no longer refers to dynamically allocated memory
#     sys/sys_notify_ddc.c(80) : allocated -> allocated : msg.param no longer refers to dynamically allocated memory
#     sys/sys_notify_ddc.c(80) : allocated -> leak : msg end scope : Memory leaked
19F501BBF5433647E1F3365D71F7959F

# False positive.
# Fortify is known to flag false memory leaks when copying structs.
#[5D5BC51D056DA1D29904F108FF8C17C7 : high : Memory Leak : controlflow ]
#
#    sys/SYS_send_telemetry.c(41) : start -> allocated : valuedup = plat_mod_mem_mng_strdup(...)
#        platform.c(485) : Branch not taken: (g_platform.mod_mem_mng_strdup == 0)
#        platform.c(488) : start -> allocated : strdup(...)
#        platform.c(488) : allocated -> allocated : return
#    sys/SYS_send_telemetry.c(41) : allocated -> allocated : valuedup refers to dynamically allocated memory
#    sys/SYS_send_telemetry.c(44) : Branch not taken: (valuedup != 0)
#    sys/SYS_send_telemetry.c(44) : Branch not taken: (topicdup != 0)
#    sys/SYS_send_telemetry.c(44) : Branch not taken: (st != 0)
#    sys/SYS_send_telemetry.c(50) : allocated -> allocated : valuedup refers to dynamically allocated memory
#    sys/SYS_send_telemetry.c(66) : Branch taken: (chan_send(c->gr->ch, (&msg)) == 0)
#    sys/SYS_send_telemetry.c(67) : allocated -> allocated : return
#    sys/SYS_send_telemetry.c(67) : allocated -> allocated : valuedup no longer refers to dynamically allocated memory
#    sys/SYS_send_telemetry.c(67) : allocated -> allocated : <AnonymousObject>.value no longer refers to dynamically allocated memory
#    sys/SYS_send_telemetry.c(67) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
#
#    sys/SYS_send_telemetry.c(41) : start -> allocated : valuedup = plat_mod_mem_mng_strdup(...)
#        platform.c(485) : Branch not taken: (g_platform.mod_mem_mng_strdup == 0)
#        platform.c(488) : start -> allocated : strdup(...)
#        platform.c(488) : allocated -> allocated : return
#    sys/SYS_send_telemetry.c(41) : allocated -> allocated : valuedup refers to dynamically allocated memory
#    sys/SYS_send_telemetry.c(44) : Branch not taken: (valuedup != 0)
#    sys/SYS_send_telemetry.c(44) : Branch not taken: (topicdup != 0)
#    sys/SYS_send_telemetry.c(44) : Branch not taken: (st != 0)
#    sys/SYS_send_telemetry.c(50) : allocated -> allocated : valuedup refers to dynamically allocated memory
#    sys/SYS_send_telemetry.c(66) : Branch not taken: (chan_send(c->gr->ch, (&msg)) != 0)
#    sys/SYS_send_telemetry.c(70) : Branch not taken: (err == 0)
#    sys/SYS_send_telemetry.c(74) : allocated -> allocated : return
#    sys/SYS_send_telemetry.c(74) : allocated -> allocated : valuedup no longer refers to dynamically allocated memory
#    sys/SYS_send_telemetry.c(74) : allocated -> allocated : <AnonymousObject>.value no longer refers to dynamically allocated memory
#    sys/SYS_send_telemetry.c(74) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
5D5BC51D056DA1D29904F108FF8C17C7

# False positive. Similar to 3F1328086D0430F812A1A7E6454DB3AE.
# [72D5694AAE0A9067D6E3BA0521ACCC95 : high : Memory Leak : controlflow ]
#
#     sys/SYS_send_telemetry.c(42) : start -> allocated : topicdup = plat_mod_mem_mng_strdup(...)
#         platform.c(485) : Branch not taken: (g_platform.mod_mem_mng_strdup == 0)
#         platform.c(488) : start -> allocated : strdup(...)
#         platform.c(488) : allocated -> allocated : return
#     sys/SYS_send_telemetry.c(42) : allocated -> allocated : topicdup refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(44) : Branch not taken: (valuedup != 0)
#     sys/SYS_send_telemetry.c(44) : Branch not taken: (topicdup != 0)
#     sys/SYS_send_telemetry.c(44) : Branch not taken: (st != 0)
#     sys/SYS_send_telemetry.c(50) : allocated -> allocated : topicdup refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(66) : Branch taken: (chan_send(c->gr->ch, (&msg)) == 0)
#     sys/SYS_send_telemetry.c(67) : allocated -> allocated : return
#     sys/SYS_send_telemetry.c(67) : allocated -> allocated : topicdup no longer refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(67) : allocated -> allocated : <AnonymousObject>.topic no longer refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(67) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
#
#     sys/SYS_send_telemetry.c(42) : start -> allocated : topicdup = plat_mod_mem_mng_strdup(...)
#         platform.c(485) : Branch not taken: (g_platform.mod_mem_mng_strdup == 0)
#         platform.c(488) : start -> allocated : strdup(...)
#         platform.c(488) : allocated -> allocated : return
#     sys/SYS_send_telemetry.c(42) : allocated -> allocated : topicdup refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(44) : Branch not taken: (valuedup != 0)
#     sys/SYS_send_telemetry.c(44) : Branch not taken: (topicdup != 0)
#     sys/SYS_send_telemetry.c(44) : Branch not taken: (st != 0)
#     sys/SYS_send_telemetry.c(50) : allocated -> allocated : topicdup refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(66) : Branch not taken: (chan_send(c->gr->ch, (&msg)) != 0)
#     sys/SYS_send_telemetry.c(70) : Branch not taken: (err == 0)
#     sys/SYS_send_telemetry.c(74) : allocated -> allocated : return
#     sys/SYS_send_telemetry.c(74) : allocated -> allocated : topicdup no longer refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(74) : allocated -> allocated : <AnonymousObject>.topic no longer refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(74) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
72D5694AAE0A9067D6E3BA0521ACCC95

# False positive. Similar to 5D5BC51D056DA1D29904F108FF8C17C7.
# [8072714A40936F004909DA9FFE5666CE : high : Memory Leak : controlflow ]
#
#     sys/SYS_send_telemetry.c(47) : Branch not taken: (valuedup != 0)
#     sys/SYS_send_telemetry.c(47) : Branch not taken: (topicdup != 0)
#     sys/SYS_send_telemetry.c(53) : start -> allocated : st = malloc(...)
#     sys/SYS_send_telemetry.c(53) : allocated -> allocated : st refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(55) : Branch not taken: (st != 0)
#     sys/SYS_send_telemetry.c(69) : allocated -> allocated : st refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(75) : Branch taken: (chan_send(c->gr->ch, (&msg)) == 0)
#     sys/SYS_send_telemetry.c(76) : allocated -> allocated : return
#     sys/SYS_send_telemetry.c(76) : allocated -> allocated : st no longer refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(76) : allocated -> allocated : msg.param no longer refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(76) : allocated -> leak : msg end scope : Memory leaked
#
#     sys/SYS_send_telemetry.c(47) : Branch not taken: (valuedup != 0)
#     sys/SYS_send_telemetry.c(47) : Branch not taken: (topicdup != 0)
#     sys/SYS_send_telemetry.c(53) : start -> allocated : st = malloc(...)
#     sys/SYS_send_telemetry.c(53) : allocated -> allocated : st refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(55) : Branch not taken: (st != 0)
#     sys/SYS_send_telemetry.c(69) : allocated -> allocated : st refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(75) : Branch not taken: (chan_send(c->gr->ch, (&msg)) != 0)
#     sys/SYS_send_telemetry.c(79) : Branch not taken: (err == 0)
#     sys/SYS_send_telemetry.c(83) : allocated -> allocated : return
#     sys/SYS_send_telemetry.c(83) : allocated -> allocated : st no longer refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(83) : allocated -> allocated : msg.param no longer refers to dynamically allocated memory
#     sys/SYS_send_telemetry.c(83) : allocated -> leak : msg end scope : Memory leaked
8072714A40936F004909DA9FFE5666CE

# False positive. Similar to 3D76C8C0B304284C4930382DB4C91610.
# [0A42A13ABB3C1DE694DF99A2C478C5E3 : high : Memory Leak : controlflow ]
#
#     telemetry.c(73) : start -> allocated : topicdup = strdup(...)
#     telemetry.c(73) : allocated -> allocated : topicdup refers to dynamically allocated memory
#     telemetry.c(76) : Branch not taken: (topicdup != 0)
#     telemetry.c(76) : Branch not taken: (valuedup != 0)
#     telemetry.c(81) : Branch not taken: (name != NULL)
#     telemetry.c(89) : Branch not taken: (e != 0)
#     telemetry.c(94) : allocated -> allocated : topicdup refers to dynamically allocated memory
#     telemetry.c(101) : allocated -> allocated : return
#     telemetry.c(101) : allocated -> allocated : topicdup no longer refers to dynamically allocated memory
#     telemetry.c(101) : allocated -> allocated : <AnonymousObject>.topic no longer refers to dynamically allocated memory
#     telemetry.c(101) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
0A42A13ABB3C1DE694DF99A2C478C5E3

# False positive. Similar to 3D76C8C0B304284C4930382DB4C91610.
# [C003135CB43C90070A17E1B150BF92A2 : high : Memory Leak : controlflow ]
#
#     telemetry.c(73) : start -> allocated : valuedup = strdup(...)
#     telemetry.c(73) : allocated -> allocated : valuedup refers to dynamically allocated memory
#     telemetry.c(76) : Branch not taken: (topicdup != 0)
#     telemetry.c(76) : Branch not taken: (valuedup != 0)
#     telemetry.c(81) : Branch not taken: (name != NULL)
#     telemetry.c(89) : Branch not taken: (e != 0)
#     telemetry.c(94) : allocated -> allocated : valuedup refers to dynamically allocated memory
#     telemetry.c(101) : allocated -> allocated : return
#     telemetry.c(101) : allocated -> allocated : valuedup no longer refers to dynamically allocated memory
#     telemetry.c(101) : allocated -> allocated : <AnonymousObject>.value no longer refers to dynamically allocated memory
#     telemetry.c(101) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
C003135CB43C90070A17E1B150BF92A2

# False positive. Similar to 3D76C8C0B304284C4930382DB4C91610.
# [68911EB72B16F27486BA3C110B75D651 : high : Memory Leak : controlflow ]
#
#     telemetry.c(76) : Branch not taken: (topicdup != 0)
#     telemetry.c(76) : Branch not taken: (valuedup != 0)
#     telemetry.c(81) : start -> allocated : name = strdup(...)
#     telemetry.c(81) : allocated -> allocated : name refers to dynamically allocated memory
#     telemetry.c(81) : Branch not taken: (name != NULL)
#     telemetry.c(89) : Branch not taken: (e != 0)
#     telemetry.c(94) : allocated -> allocated : name refers to dynamically allocated memory
#     telemetry.c(101) : allocated -> allocated : return
#     telemetry.c(101) : allocated -> allocated : name no longer refers to dynamically allocated memory
#     telemetry.c(101) : allocated -> allocated : <AnonymousObject>.module_instance no longer refers to dynamically allocated memory
#     telemetry.c(101) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
68911EB72B16F27486BA3C110B75D651

##########################################################
# Filtering Buffer Overflow issues                       #
##########################################################
# The buffer 'headers' at docker.c(205) with size
# 1 + MAX_EXTRA_HEADERS is accessed at docker.c(212) using
# 'nheaders + i' where n_headers value is 1 and i ranges
# from 0 to (n_extra_headers-1), being n_extra_headers
# guaranteed to be <= MAX_EXTRA_HEADERS in docker.c(185)
#
# So the buffer is potentially accessed from 1 to
# 1+(MAX_EXTRA_HEADERS-1) = MAX_EXTRA_HEADERS which is the
# maximum index of the array (i.e. it size minus 1) as
# expected.
#
# [3FDF4568756257D8DC3EDD2D7552AF63 : critical : Buffer Overflow : buffer ]
# libevp-agent/docker.c(219) : headers
#    Buffer Definition, headers libevp-agent/docker.c(212)
#  Buffer Size: 16 bytes
#  Write Length: 268435456 bytes
#     [var 0] i: 33554430
3FDF4568756257D8DC3EDD2D7552AF63

# [16577FB831FAF9382ABC407434B73E2D : critical : Buffer Overflow : dataflow ]
# blob_put.c(32) :  ->read(2)
#     webclient/webclient.c(1837) :  ->blob_file_read_func(1)
#     webclient/webclient.c(1832) : <=> (input_buffer_size)
#     webclient/webclient.c(1829) : <=> (todo)
#     webclient/webclient.c(1776) : <=> (ws->state_len)
#     webclient/webclient.c(1772) : <=> (len)
#     webclient/webclient.c(1836) : <- blob_file_read_func(0)
#     blob_put.c(32) : <- read(1)
#
# Fortify seems to not following properly the webclient state machine, as the
# stack goes from state WEBCLIENT_STATE_SEND_REQUEST_BODY at [1] to state
# WEBCLIENT_STATE_PREPARE_REQUEST at [2]. Also it seems to be confused when
# pointer arithmetic is used to calculate the remaining buffer size ([2]), as
# considering the read data could have an unexpected effect on subsequent read
# operations.
#
# Anyway, the usage in app code ([0] and [7]) seems correct:
#
# blob_put.c:
#
#    16  int
#    17  blob_file_read_func(void *buffer, size_t *sizep, const void **datap,
#    18                      size_t reqsize, void *vp)
#    19  {
#    20          int fd = *(int *)vp;
#    21          ssize_t read_bytes = read(fd, buffer, *sizep);
#    22          if (read_bytes == -1) {
#    23                  return -errno;
#    24          }
#    25          assert(read_bytes <= *sizep);
#    26          *sizep = (size_t)read_bytes;
#    27          return 0;
#    28  }
#
# It implements correctly one of the options described in the
# `webclient_body_callback_t` interface requirements (see webclient.h):
#
#  - Fill the buffer (specified by buffer and *sizep) with the data
#  - Update *sizep to the size of the data.
16577FB831FAF9382ABC407434B73E2D

# Fortify is confused about the webclient callbacks. See other similar filters above.
# [7387C108C41529CF409DCE4EA9CFA6F4 : high : Buffer Overflow : dataflow ]
# libevp-agent/docker.c(138) :  ->memcpy(2)
#     libevp-agent/docker.c(135) : <=> (sz)
#     libevp-agent/docker.c(168) : <=> (n)
#     libevp-agent/docker.c(161) : <=> (sz)
#     libevp-agent/docker.c(157) : <=> (datasz)
#     libevp-agent/docker.c(137) : <->memcpy(1->0)
#     libevp-agent/docker.c(127) : <=> (p)
#     libevp-agent/connections.c(103) :  ->docker_stream_fn(0->size1)
#     libevp-agent/webclient/webclient.c(2103) :  ->connections_sink_callback(0->size1)
#     libevp-agent/webclient/webclient.c(1867) : <- blob_file_read_func(0)
#     libevp-agent/blob_put.c(32) : <- read(1)
7387C108C41529CF409DCE4EA9CFA6F4

# [383076B67F70317EEDF67EEA5DD0C57C : high : Buffer Overflow : dataflow ]
# libevp-agent/docker.c(138) :  ->memcpy(2)
#     libevp-agent/docker.c(135) : <=> (sz)
#     libevp-agent/docker.c(168) : <=> (n)
#     libevp-agent/docker.c(161) : <=> (sz)
#     libevp-agent/docker.c(157) : <=> (datasz)
#     libevp-agent/docker.c(137) : <->memcpy(1->0)
#     libevp-agent/docker.c(127) : <=> (p)
#     libevp-agent/connections.c(103) :  ->docker_stream_fn(0->size1)
#     libevp-agent/webclient/webclient.c(2103) :  ->connections_sink_callback(0->size1)
#     libevp-agent/webclient/webclient.c(1949) : <- webclient_conn_recv(1)
#     libevp-agent/webclient/webclient.c(1134) : <- recv(1)
383076B67F70317EEDF67EEA5DD0C57C

# [6C9D9E2BFB0F1A698F63B112BB23FC70 : critical : Buffer Overflow : dataflow ]
# netlib/netlib_parseurl.c(199) :  ->memcpy(2)
#     netlib/netlib_parseurl.c(196) : <=> (pathlen)
#     netlib/netlib_parseurl.c(196) : <->strlen(0->return)
#     netlib/netlib_parseurl.c(127) : <=> (src)
#     netlib/netlib_parseurl.c(120) : <=> (src)
#     netlib/netlib_parseurl.c(113) : <=> (src)
#     netlib/netlib_parseurl.c(60) : <=> (src)
#     webclient/webclient.c(531) :  ->netlib_parseurl(0)
#     webclient/webclient.c(709) :  ->parseurl(0)
#     webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) :  ->wget_parseheaders(1->buffer[])
#     webclient/webclient.c(1836) : <- blob_file_read_func(0)
#     blob_put.c(32) : <- read(1)
#
# Same app code as in 16577FB831FAF9382ABC407434B73E2D. See comments given there.
6C9D9E2BFB0F1A698F63B112BB23FC70

# [AA9928668D800271E56874643DB3891A : critical : Buffer Overflow : dataflow ]
# webclient/webclient.c(312) :  ->memcpy(2)
#     webclient/webclient.c(306) : <=> (len)
#     webclient/webclient.c(306) : <->strlen(0->return)
#     webclient/webclient.c(1663) :  ->append(2)
#                     netlib/netlib_parseurl.c(191) : <=> (dest)
#                 netlib/netlib_parseurl.c(199) :  (url->path)
#                 netlib/netlib_parseurl.c(199) : <->memcpy(1->0)
#                 netlib/netlib_parseurl.c(127) : <=> (src)
#                 netlib/netlib_parseurl.c(120) : <=> (src)
#                 netlib/netlib_parseurl.c(113) : <=> (src)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->path)
#         webclient/webclient.c(709) : <->parseurl(0->1->filename)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.filename)
#     webclient/webclient.c(1836) : <- blob_file_read_func(0)
#     blob_put.c(32) : <- read(1)
#
# Same app code as in E12052FD2D97AD1AFD9C2F5BD24915DC. See comments given there.
AA9928668D800271E56874643DB3891A

# [2630F717FB9BF53A373754E93F3E4300 : high : Buffer Overflow : dataflow ]
# netlib/netlib_parseurl.c(200) : <=> (dest[])
#     netlib/netlib_parseurl.c(196) : <=> (pathlen)
#     netlib/netlib_parseurl.c(196) : <->strlen(0->return)
#     netlib/netlib_parseurl.c(127) : <=> (src)
#     netlib/netlib_parseurl.c(120) : <=> (src)
#     netlib/netlib_parseurl.c(113) : <=> (src)
#     netlib/netlib_parseurl.c(60) : <=> (src)
#     webclient/webclient.c(531) :  ->netlib_parseurl(0)
#     webclient/webclient.c(709) :  ->parseurl(0)
#     webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) :  ->wget_parseheaders(1->buffer[])
#     webclient/webclient.c(1836) : <- blob_file_read_func(0)
#     blob_put.c(32) : <- read(1)
#
# Same app code as in 16577FB831FAF9382ABC407434B73E2D. See comments given there.
2630F717FB9BF53A373754E93F3E4300

# [295D446BFDC6C795CB208B02DF640812 : high : Buffer Overflow : dataflow ]
# webclient/webclient.c(313) : <=> (dest[])
#     webclient/webclient.c(306) : <=> (len)
#     webclient/webclient.c(306) : <->strlen(0->return)
#     webclient/webclient.c(1663) :  ->append(2)
#                     netlib/netlib_parseurl.c(191) : <=> (dest)
#                 netlib/netlib_parseurl.c(199) :  (url->path)
#                 netlib/netlib_parseurl.c(199) : <->memcpy(1->0)
#                 netlib/netlib_parseurl.c(127) : <=> (src)
#                 netlib/netlib_parseurl.c(120) : <=> (src)
#                 netlib/netlib_parseurl.c(113) : <=> (src)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->path)
#         webclient/webclient.c(709) : <->parseurl(0->1->filename)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.filename)
#     webclient/webclient.c(1836) : <- blob_file_read_func(0)
#     blob_put.c(32) : <- read(1)
#
# Same app code as in E12052FD2D97AD1AFD9C2F5BD24915DC. See comments given there.
295D446BFDC6C795CB208B02DF640812

# Fortify seems unhappy with the buffer management in webclient.
# The following trace made me (yamamoto) think Fortify is not smart enough
# to understand the state machine in webclient.
# I (yamamoto) couldn't find any buffer overflows around it.
#
# [1BD8A1F8CCBBD231AD87D886A82B316A : critical : Buffer Overflow : dataflow ]
# blob_put.c(32) :  ->read(2)
#     webclient/webclient.c(1837) :  ->blob_file_read_func(1)
#     webclient/webclient.c(1832) : <=> (input_buffer_size)
#     webclient/webclient.c(1829) : <=> (todo)
#     webclient/webclient.c(1776) : <=> (ws->state_len)
#     webclient/webclient.c(1772) : <=> (len)
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
1BD8A1F8CCBBD231AD87D886A82B316A

# I (yamamoto) am not sure what Fortify is complaining about.
#
# * The buffer here (ws->line) is ensured to be NUL-terminated.
# * "pathlen" is set to the reasonable size
# * E2BIG check for "pathlen" seems ok.
#
# [F0433DB1C9E7E5F93226CD403E37BBCD : critical : Buffer Overflow : dataflow ]
# netlib/netlib_parseurl.c(199) :  ->memcpy(2)
#     netlib/netlib_parseurl.c(196) : <=> (pathlen)
#     netlib/netlib_parseurl.c(196) : <->strlen(0->return)
#     netlib/netlib_parseurl.c(127) : <=> (src)
#     netlib/netlib_parseurl.c(120) : <=> (src)
#     netlib/netlib_parseurl.c(113) : <=> (src)
#     netlib/netlib_parseurl.c(60) : <=> (src)
#     webclient/webclient.c(531) :  ->netlib_parseurl(0)
#     webclient/webclient.c(709) :  ->parseurl(0)
#     webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) :  ->wget_parseheaders(1->buffer[])
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
F0433DB1C9E7E5F93226CD403E37BBCD

# I (yamamoto) am not sure what Fortify is complaining about.
#
# * "append" checks the size of the destination buffer.
# * "parseurl" always NUL-terminates "filename" even in the case of E2BIG.
#
# [A794FEEDC078AB491246965FBD4C4CC0 : critical : Buffer Overflow : dataflow ]
# webclient/webclient.c(312) :  ->memcpy(2)
#     webclient/webclient.c(306) : <=> (len)
#     webclient/webclient.c(306) : <->strlen(0->return)
#     webclient/webclient.c(1663) :  ->append(2)
#                     netlib/netlib_parseurl.c(191) : <=> (dest)
#                 netlib/netlib_parseurl.c(199) :  (url->path)
#                 netlib/netlib_parseurl.c(199) : <->memcpy(1->0)
#                 netlib/netlib_parseurl.c(127) : <=> (src)
#                 netlib/netlib_parseurl.c(120) : <=> (src)
#                 netlib/netlib_parseurl.c(113) : <=> (src)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->path)
#         webclient/webclient.c(709) : <->parseurl(0->1->filename)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.filename)
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
A794FEEDC078AB491246965FBD4C4CC0

# I (yamamoto) am not sure what Fortify is complaining about.
#
# * The buffer here (ws->line) is ensured to be NUL-terminated.
# * "pathlen" is set to the reasonable size
# * E2BIG check for "pathlen" seems ok.
#
# [DF706016981CB406C13D19ECE23C91A7 : high : Buffer Overflow : dataflow ]
# netlib/netlib_parseurl.c(200) : <=> (dest[])
#     netlib/netlib_parseurl.c(196) : <=> (pathlen)
#     netlib/netlib_parseurl.c(196) : <->strlen(0->return)
#     netlib/netlib_parseurl.c(127) : <=> (src)
#     netlib/netlib_parseurl.c(120) : <=> (src)
#     netlib/netlib_parseurl.c(113) : <=> (src)
#     netlib/netlib_parseurl.c(60) : <=> (src)
#     webclient/webclient.c(531) :  ->netlib_parseurl(0)
#     webclient/webclient.c(709) :  ->parseurl(0)
#     webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) :  ->wget_parseheaders(1->buffer[])
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
DF706016981CB406C13D19ECE23C91A7

# I (yamamoto) am not sure what Fortify is complaining about.
#
# * "append" checks the size of the destination buffer.
# * "parseurl" always NUL-terminates "filename" even in the case of E2BIG.
#
# [19E004C06EDF4F72D334861F1A5B826C : high : Buffer Overflow : dataflow ]
# webclient/webclient.c(313) : <=> (dest[])
#     webclient/webclient.c(306) : <=> (len)
#     webclient/webclient.c(306) : <->strlen(0->return)
#     webclient/webclient.c(1663) :  ->append(2)
#                     netlib/netlib_parseurl.c(191) : <=> (dest)
#                 netlib/netlib_parseurl.c(199) :  (url->path)
#                 netlib/netlib_parseurl.c(199) : <->memcpy(1->0)
#                 netlib/netlib_parseurl.c(127) : <=> (src)
#                 netlib/netlib_parseurl.c(120) : <=> (src)
#                 netlib/netlib_parseurl.c(113) : <=> (src)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->path)
#         webclient/webclient.c(709) : <->parseurl(0->1->filename)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.filename)
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
19E004C06EDF4F72D334861F1A5B826C

# wk_ind is passed to the worker thread and freed at the end of worker_job_process().
#[2D6F9CD5A08ECCDB9C51BE7B4865ADC0 : high : Memory Leak : controlflow ]
#
#    work.c(202) : Branch not taken: (worker->should_live != 0)
#    work.c(210) : start -> allocated : wk_ind = xmalloc(...)
#    work.c(210) : allocated -> allocated : wk_ind refers to dynamically allocated memory
#    work.c(215) : Branch not taken: (worker->max_jobs > 1)
#    work.c(222) : Branch not taken: (worker->cur_jobs != worker->max_jobs)
#    work.c(232) : allocated -> allocated : worker_job_start(wk_ind)
#        work.c(104) : allocated -> allocated : wk_ind refers to dynamically allocated memory
#        work.c(114) : allocated -> allocated : xpthread_create(?, ?, wk_ind, ?, ?)
#            xpthread.c(115) : allocated -> allocated : arg refers to dynamically allocated memory
#            xpthread.c(122) : Branch taken: (ret != 0)
#            xpthread.c(124) : goto
#        work.c(116) : Branch taken: (ret != 0)
#        work.c(118) : allocated -> allocated : return
#    work.c(233) : Branch taken: (ret == 0)
#    work.c(246) : allocated -> allocated : wk_ind no longer refers to dynamically allocated memory
#    work.c(246) : allocated -> leak : wk_ind end scope : Memory leaked
2D6F9CD5A08ECCDB9C51BE7B4865ADC0

# False positive. Similar to C781B5DEB3632ED9CA3155BF0F46DCEE.
# [79FED47A7079CACA4E5E3C7AB8711C2A : high : Memory Leak : controlflow ]
#
#     sys/SYS_set_state.c(33) : start -> allocated : valuedup = plat_mod_mem_mng_strdup(...)
#         platform.c(485) : Branch not taken: (g_platform.mod_mem_mng_strdup == 0)
#         platform.c(488) : start -> allocated : strdup(...)
#         platform.c(488) : allocated -> allocated : return
#     sys/SYS_set_state.c(33) : allocated -> allocated : valuedup refers to dynamically allocated memory
#     sys/SYS_set_state.c(36) : Branch not taken: (valuedup != NULL)
#     sys/SYS_set_state.c(41) : Branch not taken: (string_map_insert(gr->state_map, s->key, valuedup, (1 != 0)) == 0)
#     sys/SYS_set_state.c(48) : allocated -> allocated : valuedup no longer refers to dynamically allocated memory
#     sys/SYS_set_state.c(48) : allocated -> leak : valuedup end scope : Memory leaked
79FED47A7079CACA4E5E3C7AB8711C2A

# False positive.
# Fortify is known to falsely flag memory leaks when two structs with
# pointers in them are copied.
# [FDD4B8E1FB771BD67A32841628128132 : high : Memory Leak : controlflow ]
#
#     sys/sys_client_alloc.c(24) : start -> allocated : h = sdk_handle_alloc()
#         sdk.c(968) : start -> allocated : h = xcalloc_internal(...)
#             util.c(193) : start -> allocated : vp = calloc(...)
#             util.c(193) : allocated -> allocated : vp refers to dynamically allocated memory
#             util.c(194) : Branch not taken: (vp != NULL)
#             util.c(197) : allocated -> allocated : return
#         sdk.c(968) : allocated -> allocated : h refers to dynamically allocated memory
#         sdk.c(969) : allocated -> allocated : return
#     sys/sys_client_alloc.c(24) : allocated -> allocated : h refers to dynamically allocated memory
#     sys/sys_client_alloc.c(28) : Branch not taken: (h != NULL)
#     sys/sys_client_alloc.c(37) : Branch not taken: (ch != NULL)
#     sys/sys_client_alloc.c(44) : Branch not taken: (ret != NULL)
#     sys/sys_client_alloc.c(48) : allocated -> allocated : h refers to dynamically allocated memory
#     sys/sys_client_alloc.c(54) : allocated -> allocated : return
#     sys/sys_client_alloc.c(54) : allocated -> allocated : h no longer refers to dynamically allocated memory
#     sys/sys_client_alloc.c(54) : allocated -> allocated : <AnonymousObject>.h no longer refers to dynamically allocated memory
#     sys/sys_client_alloc.c(54) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
FDD4B8E1FB771BD67A32841628128132

# False positive. Similar to FDD4B8E1FB771BD67A32841628128132.
# [034CA66405B586E2430D473A72C69837 : high : Memory Leak : controlflow ]
#
#     sys/SYS_set_configuration_cb.c(57) : start -> allocated : cfg = malloc(...)
#     sys/SYS_set_configuration_cb.c(57) : allocated -> allocated : cfg refers to dynamically allocated memory
#     sys/SYS_set_configuration_cb.c(59) : Branch not taken: (cfg != 0)
#     sys/SYS_set_configuration_cb.c(73) : allocated -> allocated : cfg refers to dynamically allocated memory
#     sys/SYS_set_configuration_cb.c(80) : Branch not taken: (chan_send(c->gr->ch, (&msg)) != 0)
#     sys/SYS_set_configuration_cb.c(85) : allocated -> allocated : cfg no longer refers to dynamically allocated memory
#     sys/SYS_set_configuration_cb.c(85) : allocated -> allocated : <AnonymousObject>.cfg no longer refers to dynamically allocated memory
#     sys/SYS_set_configuration_cb.c(85) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
034CA66405B586E2430D473A72C69837

# False positive. Similar to FDD4B8E1FB771BD67A32841628128132.
# [FE198BBEF7197E19F030FF2AAE7CC32C : high : Memory Leak : controlflow ]
#
#     sys/sys_notify_config.c(71) : Branch not taken: (stype != 2)
#     sys/sys_notify_config.c(76) : Branch not taken: (cfg->type == 2)
#     sys/sys_notify_config.c(84) : Branch not taken: (topicdup != NULL)
#     sys/sys_notify_config.c(89) : start -> allocated : valuedup = strdup(...)
#     sys/sys_notify_config.c(89) : allocated -> allocated : valuedup refers to dynamically allocated memory
#     sys/sys_notify_config.c(89) : Branch not taken: (valuedup != NULL)
#     sys/sys_notify_config.c(94) : Branch not taken: (cl != NULL)
#     sys/sys_notify_config.c(99) : allocated -> allocated : valuedup refers to dynamically allocated memory
#     sys/sys_notify_config.c(110) : Branch not taken: (chan_send(cfg->c->ch, (&msg)) != 0)
#     sys/sys_notify_config.c(116) : allocated -> allocated : return
#     sys/sys_notify_config.c(116) : allocated -> allocated : valuedup no longer refers to dynamically allocated memory
#     sys/sys_notify_config.c(116) : allocated -> allocated : <AnonymousObject>.value no longer refers to dynamically allocated memory
#     sys/sys_notify_config.c(116) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
FE198BBEF7197E19F030FF2AAE7CC32C

# False positive. Similar to FDD4B8E1FB771BD67A32841628128132.
# [279A9D030BE22D56DDB0F231C6525E73 : high : Memory Leak : controlflow ]
#
#     sys/sys_notify_config.c(71) : Branch not taken: (stype != 2)
#     sys/sys_notify_config.c(76) : Branch not taken: (cfg->type == 2)
#     sys/sys_notify_config.c(84) : Branch not taken: (topicdup != NULL)
#     sys/sys_notify_config.c(89) : Branch not taken: (valuedup != NULL)
#     sys/sys_notify_config.c(94) : start -> allocated : cl = malloc(...)
#     sys/sys_notify_config.c(94) : allocated -> allocated : cl refers to dynamically allocated memory
#     sys/sys_notify_config.c(94) : Branch not taken: (cl != NULL)
#     sys/sys_notify_config.c(106) : allocated -> allocated : cl refers to dynamically allocated memory
#     sys/sys_notify_config.c(110) : Branch not taken: (chan_send(cfg->c->ch, (&msg)) != 0)
#     sys/sys_notify_config.c(116) : allocated -> allocated : return
#     sys/sys_notify_config.c(116) : allocated -> allocated : cl no longer refers to dynamically allocated memory
#     sys/sys_notify_config.c(116) : allocated -> allocated : msg.param no longer refers to dynamically allocated memory
#     sys/sys_notify_config.c(116) : allocated -> leak : msg end scope : Memory leaked
279A9D030BE22D56DDB0F231C6525E73

##########################################################
# Filtering String Termination Error                     #
##########################################################
# The following issues are produced by dataflow analysis on
# data in code from 3rd party libraries (webclient,
# netlib, etc).
#
# Third party software is excluded from requirements
# see issue EVP-142

# Seemingly false-positive
# ws->line is ensured NUL-terminated
#
# [BDD71F0888DEDD5C8243F740C2B231DD : high : String Termination Error : dataflow ]
# webclient/webclient.c(439) :  ->strtoul(0)
#     webclient/webclient.c(435) : <=> (dest)
#     webclient/webclient.c(398) : <=> (ws->line[])
#     webclient/webclient.c(1961) :  ->wget_parsestatus(1->buffer[])
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
BDD71F0888DEDD5C8243F740C2B231DD

# Seemingly false-positive
# ws->line is ensured NUL-terminated
# parseurl ensures NUL-termination of "scheme"
#
# [15CD1D2DD4FF0B55304C1271F3C72EEC : high : String Termination Error : dataflow ]
# webclient/webclient.c(544) :  ->strcmp(0)
#     webclient/webclient.c(710) :  ->parseurl(1->scheme)
#     webclient/webclient.c(1972) :  ->wget_parseheaders(1->target.scheme)
#                 netlib/netlib_parseurl.c(90) :  (url->scheme)
#                 netlib/netlib_parseurl.c(90) : <=> (dest)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->scheme)
#         webclient/webclient.c(709) : <->parseurl(0->1->scheme)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.scheme)
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
15CD1D2DD4FF0B55304C1271F3C72EEC

# Seemingly false-positive
# ws->line is ensured NUL-terminated
#
# [E6768D357EBBA899F69E1B7C23262DD3 : high : String Termination Error : dataflow ]
# webclient/webclient.c(746) :  ->strcasecmp(0)
#     webclient/webclient.c(743) : <=> (encodings)
#     webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) :  ->wget_parseheaders(1->buffer[])
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
E6768D357EBBA899F69E1B7C23262DD3

# Seemingly false-positive
# ws->line is ensured NUL-terminated
# parseurl ensures NUL-termination of "scheme"
#
# [D5742A208D1A628D9910EE515A424F25 : high : String Termination Error : dataflow ]
# webclient/webclient.c(1284) :  ->strcmp(0)
#                 netlib/netlib_parseurl.c(90) :  (url->scheme)
#                 netlib/netlib_parseurl.c(90) : <=> (dest)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->scheme)
#         webclient/webclient.c(709) : <->parseurl(0->1->scheme)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.scheme)
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
D5742A208D1A628D9910EE515A424F25

# Seemingly false-positive
# ws->line is ensured NUL-terminated
# parseurl ensures NUL-termination of "scheme"
#
# [AD02861F648C8948AFC7349431EB96F3 : high : String Termination Error : dataflow ]
# webclient/webclient.c(1290) :  ->strcmp(0)
#                 netlib/netlib_parseurl.c(90) :  (url->scheme)
#                 netlib/netlib_parseurl.c(90) : <=> (dest)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->scheme)
#         webclient/webclient.c(709) : <->parseurl(0->1->scheme)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.scheme)
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
AD02861F648C8948AFC7349431EB96F3

# Seemingly false-positive
# ws->line is ensured NUL-terminated
#
# [0067067905578F4A93C8B435EB33AC9C : high : String Termination Error : dataflow ]
# webclient/webclient.c(658) :  ->strchr(0)
#     webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) :  ->wget_parseheaders(1->buffer[])
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
0067067905578F4A93C8B435EB33AC9C

# Seemingly false-positive
# ws->line is ensured NUL-terminated
#
# [14FE6B440EB714D415F51F4F60334253 : high : String Termination Error : dataflow ]
# webclient/webclient.c(848) :  ->strchr(0)
#     webclient/webclient.c(808) : <=> (ws->line[])
#     webclient/webclient.c(1983) :  ->wget_parsechunkheader(1->buffer[])
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
14FE6B440EB714D415F51F4F60334253

# Seemingly false-positive
# ws->line is ensured NUL-terminated
#
# [9CB619A2F6C46E9B525CDB0F85737C16 : high : String Termination Error : dataflow ]
# webclient/webclient.c(460) :  ->strncpy(1)
#     webclient/webclient.c(439) : <->strtoul(0->1)
#     webclient/webclient.c(435) : <=> (dest)
#     webclient/webclient.c(398) : <=> (ws->line[])
#     webclient/webclient.c(1961) :  ->wget_parsestatus(1->buffer[])
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
9CB619A2F6C46E9B525CDB0F85737C16

# Seemingly false-positive
# The buffer is big enough to store any possible values of uint16_t
# formatted with %u.
#
# [6206B66F681AE8046C2E25231A85F599 : high : String Termination Error : dataflow ]
# webclient/webclient.c(1522) :  ->snprintf(3)
#             webclient/webclient.c(555) : <=> (targ->port)
#                 netlib/netlib_parseurl.c(173) : <=> (url->port)
#                 netlib/netlib_parseurl.c(169) : <=> (accum)
#                 netlib/netlib_parseurl.c(165) : <=> (src)
#                 netlib/netlib_parseurl.c(127) : <=> (src)
#                 netlib/netlib_parseurl.c(120) : <=> (src)
#                 netlib/netlib_parseurl.c(113) : <=> (src)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->port)
#         webclient/webclient.c(709) : <->parseurl(0->1->port)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.port)
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
6206B66F681AE8046C2E25231A85F599

# Seemingly false-positive
# The buffer is big enough to store any possible values of uint16_t
# formatted with %u.
#
# [C446AD9D03BF5A1984A69C0939392CE4 : high : String Termination Error : dataflow ]
# webclient/webclient.c(1645) :  ->snprintf(3)
#     webclient/webclient.c(1434) :  ->webclient_perform(0->tunnel_target_port)
#         webclient/webclient.c(1340) : <=> (ws->tunnel)
#     webclient/webclient.c(1351) :  (ws->tunnel->tunnel_target_port)
#     webclient/webclient.c(1351) : <=> (tunnel->tunnel_target_port)
#             webclient/webclient.c(555) : <=> (targ->port)
#                 netlib/netlib_parseurl.c(173) : <=> (url->port)
#                 netlib/netlib_parseurl.c(169) : <=> (accum)
#                 netlib/netlib_parseurl.c(165) : <=> (src)
#                 netlib/netlib_parseurl.c(127) : <=> (src)
#                 netlib/netlib_parseurl.c(120) : <=> (src)
#                 netlib/netlib_parseurl.c(113) : <=> (src)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->port)
#         webclient/webclient.c(709) : <->parseurl(0->1->port)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.port)
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
C446AD9D03BF5A1984A69C0939392CE4

# Seemingly false-positive
# The buffer is big enough to store any possible values of uint16_t
# formatted with %u.
#
# [C714A975E2BD916E72FFF2D2A9F8EEE5 : high : String Termination Error : dataflow ]
# webclient/webclient.c(1661) :  ->snprintf(3)
#             webclient/webclient.c(555) : <=> (targ->port)
#                 netlib/netlib_parseurl.c(173) : <=> (url->port)
#                 netlib/netlib_parseurl.c(169) : <=> (accum)
#                 netlib/netlib_parseurl.c(165) : <=> (src)
#                 netlib/netlib_parseurl.c(127) : <=> (src)
#                 netlib/netlib_parseurl.c(120) : <=> (src)
#                 netlib/netlib_parseurl.c(113) : <=> (src)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->port)
#         webclient/webclient.c(709) : <->parseurl(0->1->port)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.port)
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
C714A975E2BD916E72FFF2D2A9F8EEE5

# ws->line is ensured NUL-terminated
# Every skipped characters are checked against NUL.
#
# [10E4DA672504849EE7141D511C642A9F : high : String Termination Error : dataflow ]
# netlib/netlib_parseurl.c(196) :  ->strlen(0)
#     netlib/netlib_parseurl.c(127) : <=> (src)
#     netlib/netlib_parseurl.c(120) : <=> (src)
#     netlib/netlib_parseurl.c(113) : <=> (src)
#     netlib/netlib_parseurl.c(60) : <=> (src)
#     webclient/webclient.c(531) :  ->netlib_parseurl(0)
#     webclient/webclient.c(709) :  ->parseurl(0)
#     webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) :  ->wget_parseheaders(1->buffer[])
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
10E4DA672504849EE7141D511C642A9F

# Seemingly false-positive
# parseurl ensures NUL termination of filename
#
# [F15E2D875CE33A87D30FDD4FC807BBF1 : high : String Termination Error : dataflow ]
# webclient/webclient.c(306) :  ->strlen(0)
#     webclient/webclient.c(1663) :  ->append(2)
#                     netlib/netlib_parseurl.c(191) : <=> (dest)
#                 netlib/netlib_parseurl.c(199) :  (url->path)
#                 netlib/netlib_parseurl.c(199) : <->memcpy(1->0)
#                 netlib/netlib_parseurl.c(127) : <=> (src)
#                 netlib/netlib_parseurl.c(120) : <=> (src)
#                 netlib/netlib_parseurl.c(113) : <=> (src)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->path)
#         webclient/webclient.c(709) : <->parseurl(0->1->filename)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.filename)
#     webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#     webclient/webclient.c(1115) : <- recv(1)
#
#     timeutil.c(80) : start -> allocated : localtime_r(...) : localtime_r may return NULL
#     timeutil.c(80) : allocated -> used : localtime_r((&now.tv_sec), (&ltime)) : return value used without null check
#
#     sdk.c(201) : Branch taken: (h != NULL)
#     sdk.c(201) : Branch taken: (h->exiting == 0)
#     sdk.c(203) : start -> defined : Declaration of config
#     sdk.c(212) : Branch taken: (event != NULL)
#     sdk.c(213) : defined -> used : config : Variable config used without being initialized
#
#     blob_get.c(52) : Branch taken: (wk->tmpname_template != NULL)
#     blob_get.c(54) : Branch not taken: (last_delim != NULL)
#     blob_get.c(62) : Branch not taken: (ret != -1)
#     blob_get.c(64) : Branch not taken: (ret < 4096)
#     blob_get.c(69) : start -> mkstempState : mkstemp(...)
F15E2D875CE33A87D30FDD4FC807BBF1

# netlib_parseurl either returns a negative value or ensures NUL
#  termination of scheme.
# [E2418E0A8BC3A67039E4AFDA4945E218 : high : String Termination Error : dataflow ]
# webclient/webclient.c(544) :  ->strcmp(0)
#     webclient/webclient.c(710) :  ->parseurl(1->scheme)
#     webclient/webclient.c(1972) :  ->wget_parseheaders(1->target.scheme)
#                 netlib/netlib_parseurl.c(90) :  (url->scheme)
#                 netlib/netlib_parseurl.c(90) : <=> (dest)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->scheme)
#         webclient/webclient.c(709) : <->parseurl(0->1->scheme)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.scheme)
#     webclient/webclient.c(1836) : <- blob_file_read_func(0)
#     blob_put.c(32) : <- read(1)
E2418E0A8BC3A67039E4AFDA4945E218

# netlib_parseurl either returns a negative value or ensures NUL
# termination of scheme.
# [9C8B6844395149F0182C1D129F1BB602 : high : String Termination Error : dataflow ]
# webclient/webclient.c(1284) :  ->strcmp(0)
#                 netlib/netlib_parseurl.c(90) :  (url->scheme)
#                 netlib/netlib_parseurl.c(90) : <=> (dest)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->scheme)
#         webclient/webclient.c(709) : <->parseurl(0->1->scheme)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.scheme)
#     webclient/webclient.c(1836) : <- blob_file_read_func(0)
#     blob_put.c(32) : <- read(1)
9C8B6844395149F0182C1D129F1BB602

# netlib_parseurl either returns a negative value or ensures NUL
# termination of scheme.
# [AC266328DD1A4A32597073137D246C6D : high : String Termination Error : dataflow ]
# webclient/webclient.c(1290) :  ->strcmp(0)
#                 netlib/netlib_parseurl.c(90) :  (url->scheme)
#                 netlib/netlib_parseurl.c(90) : <=> (dest)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->scheme)
#         webclient/webclient.c(709) : <->parseurl(0->1->scheme)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.scheme)
#     webclient/webclient.c(1836) : <- blob_file_read_func(0)
#     blob_put.c(32) : <- read(1)
AC266328DD1A4A32597073137D246C6D

# I (yamamoto) am not sure what fortify is complaining here.
# * "port" is uint16_t and the buffer is big enough to store every
#   possible values + the terminating NUL.
# * While snprintf result should be checked, snprintf is unlikely
#   to fail with other reasons.
# [6979589A0117F66CB267A6F7CD9301D9 : high : String Termination Error : dataflow ]
# webclient/webclient.c(1522) :  ->snprintf(3)
#             webclient/webclient.c(555) : <=> (targ->port)
#                 netlib/netlib_parseurl.c(173) : <=> (url->port)
#                 netlib/netlib_parseurl.c(169) : <=> (accum)
#                 netlib/netlib_parseurl.c(165) : <=> (src)
#                 netlib/netlib_parseurl.c(127) : <=> (src)
#                 netlib/netlib_parseurl.c(120) : <=> (src)
#                 netlib/netlib_parseurl.c(113) : <=> (src)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->port)
#         webclient/webclient.c(709) : <->parseurl(0->1->port)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.port)
#     webclient/webclient.c(1836) : <- blob_file_read_func(0)
#     blob_put.c(32) : <- read(1)
6979589A0117F66CB267A6F7CD9301D9

# I (yamamoto) am not sure what fortify is complaining here.
# * "port" is uint16_t and the buffer is big enough to store every
#   possible values + the terminating NUL.
# * While snprintf result should be checked, snprintf is unlikely
#   to fail with other reasons.
# [A3189AAAD369C3CECDF244305F54F9D5 : high : String Termination Error : dataflow ]
# webclient/webclient.c(1661) :  ->snprintf(3)
#             webclient/webclient.c(555) : <=> (targ->port)
#                 netlib/netlib_parseurl.c(173) : <=> (url->port)
#                 netlib/netlib_parseurl.c(169) : <=> (accum)
#                 netlib/netlib_parseurl.c(165) : <=> (src)
#                 netlib/netlib_parseurl.c(127) : <=> (src)
#                 netlib/netlib_parseurl.c(120) : <=> (src)
#                 netlib/netlib_parseurl.c(113) : <=> (src)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->port)
#         webclient/webclient.c(709) : <->parseurl(0->1->port)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.port)
#     webclient/webclient.c(1836) : <- blob_file_read_func(0)
#     blob_put.c(32) : <- read(1)
A3189AAAD369C3CECDF244305F54F9D5

# Discarded since it is a false positive.
# <- read(1)
# Fortify cannot verify the origin of the data, since it is read from a socket.
# Then, it does not find an explicit '\0' at the end.
# Same app code as in #########################. See comments given there.

#[274111BDDE4AC18002694AE1335B76FB : high : String Termination Error : dataflow ]
#webclient/webclient.c(439) :  ->strtoul(0)
#    webclient/webclient.c(435) : <=> (dest)
#    webclient/webclient.c(398) : <=> (ws->line[])
#    webclient/webclient.c(1961) :  ->wget_parsestatus(1->buffer[])
#    webclient/webclient.c(1836) : <- blob_file_read_func(0)
#    blob_put.c(32) : <- read(1)
274111BDDE4AC18002694AE1335B76FB

#[49525399D99049845C0688A52ABDF9E0 : high : String Termination Error : dataflow ]
#webclient/webclient.c(460) :  ->strncpy(1)
#    webclient/webclient.c(439) : <->strtoul(0->1)
#    webclient/webclient.c(435) : <=> (dest)
#    webclient/webclient.c(398) : <=> (ws->line[])
#    webclient/webclient.c(1961) :  ->wget_parsestatus(1->buffer[])
#    webclient/webclient.c(1836) : <- blob_file_read_func(0)
#    blob_put.c(32) : <- read(1)
49525399D99049845C0688A52ABDF9E0

#[C382DF34B7262C9187069ABBC7FEEDCF : high : String Termination Error : dataflow ]
#webclient/webclient.c(658) :  ->strchr(0)
#    webclient/webclient.c(579) : <=> (ws->line[])
#    webclient/webclient.c(1972) :  ->wget_parseheaders(1->buffer[])
#    webclient/webclient.c(1836) : <- blob_file_read_func(0)
#    blob_put.c(32) : <- read(1)
C382DF34B7262C9187069ABBC7FEEDCF

#[1E364DCF285BF308B956D650C8CC39C1 : high : String Termination Error : dataflow ]
#netlib/netlib_parseurl.c(196) :  ->strlen(0)
#    netlib/netlib_parseurl.c(127) : <=> (src)
#    netlib/netlib_parseurl.c(120) : <=> (src)
#    netlib/netlib_parseurl.c(113) : <=> (src)
#    netlib/netlib_parseurl.c(60) : <=> (src)
#    webclient/webclient.c(531) :  ->netlib_parseurl(0)
#    webclient/webclient.c(709) :  ->parseurl(0)
#    webclient/webclient.c(579) : <=> (ws->line[])
#    webclient/webclient.c(1972) :  ->wget_parseheaders(1->buffer[])
#    webclient/webclient.c(1836) : <- blob_file_read_func(0)
#    blob_put.c(32) : <- read(1)
1E364DCF285BF308B956D650C8CC39C1

#[6F6BF2A9C0A42108A531B623947C284D : high : String Termination Error : dataflow ]
#webclient/webclient.c(306) :  ->strlen(0)
#    webclient/webclient.c(1663) :  ->append(2)
#                    netlib/netlib_parseurl.c(191) : <=> (dest)
#                netlib/netlib_parseurl.c(199) :  (url->path)
#                netlib/netlib_parseurl.c(199) : <->memcpy(1->0)
#                netlib/netlib_parseurl.c(127) : <=> (src)
#                netlib/netlib_parseurl.c(120) : <=> (src)
#                netlib/netlib_parseurl.c(113) : <=> (src)
#                netlib/netlib_parseurl.c(60) : <=> (src)
#            webclient/webclient.c(531) : <->netlib_parseurl(0->1->path)
#        webclient/webclient.c(709) : <->parseurl(0->1->filename)
#        webclient/webclient.c(579) : <=> (ws->line[])
#    webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.filename)
#    webclient/webclient.c(1836) : <- blob_file_read_func(0)
#    blob_put.c(32) : <- read(1)
6F6BF2A9C0A42108A531B623947C284D

# Seemingly false-positive.  ws->line is ensured NUL-terminated before
# being fed into these string functions.
# Also, Fortify seems to be confused by the buffer usage in webclient.
# (It uses the same buffer for both of send and receive.)
#
# [42BF5315C3F150A06440378D1D0AB7EB : high : String Termination Error : dataflow ]
# webclient/webclient.c(746) :  ->strcasecmp(0)
#     webclient/webclient.c(743) : <=> (encodings)
#     webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) :  ->wget_parseheaders(1->buffer[])
#     webclient/webclient.c(1836) : <- blob_file_read_func(0)
#     blob_put.c(32) : <- read(1)
#
# [3E47B7656D8FA09BFFF72C5987A993F3 : high : String Termination Error : dataflow ]
# webclient/webclient.c(848) :  ->strchr(0)
#     webclient/webclient.c(808) : <=> (ws->line[])
#     webclient/webclient.c(1983) :  ->wget_parsechunkheader(1->buffer[])
#     webclient/webclient.c(1836) : <- blob_file_read_func(0)
#     blob_put.c(32) : <- read(1)
#
42BF5315C3F150A06440378D1D0AB7EB
3E47B7656D8FA09BFFF72C5987A993F3

# Discarded since it is a false positive.
# <- read(1)
# Fortify cannot verify the origin of the data, since it is read from a socket.
# Then, it does not find an explicit '\0' at the end.
# But the read string is a FlatBuffer string, and FlatBuffer already ensures
# that strings ends with '\0'. From their documentation:
# https://github.com/dvidelabs/flatcc/blame/master/doc/builder.md#L653
# "Strings are generally expected to be utf-8, but any binary data will be
# stored. Zero termination or embedded control codes are includes as is.
# The string gets a final zero termination regardless, not counted in the
# string length (in compliance with the FlatBuffers format)."

#[3397B3B424EF87DF712DEFD26B45C7AC : high : String Termination Error : dataflow ]
#sdk.c(1059) :  ->strcmp(1)
#    sdk_remote.c(403) :  ->EVP_impl_sendState(2)
#    sdk_remote.c(397) : <=> (topic)
#        /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(583) : return
#        /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(583) : <=> (elem__tmp)
#    sdk_remote.c(397) : <->EVP_SDK_StateInput_topic(0->return)
#    sdk_remote.c(394) : <=> (state)
#        /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(1033) : return
#        /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(1033) : <=> (elem__tmp)
#    sdk_remote.c(394) : <->EVP_SDK_Request_body(0->return)
#    sdk_remote.c(952) :  ->process_send_state(1)
#    sdk_remote.c(909) : <=> (req)
#        /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(1031) : return
#    sdk_remote.c(909) : <->EVP_SDK_Request_as_root(0->return)
#    sdkrpc/server.c(96) :  ->sdk_process_request(0)
#    sdkrpc/server.c(85) : <- readall(1)
#    ioutil.c(22) : <- read(1)
#
## StateInput_topic is a Flatbuffer String. In sdkenc/sdk.fbs:
# table StateInput {
#     topic:string (required);
3397B3B424EF87DF712DEFD26B45C7AC

# StateInput_topic is a Flatbuffer String. In sdkenc/sdk.fbs:
#[263E550BDAD8048B7714327862E5FA4B : high : String Termination Error : dataflow ]
#sdk.c(1008) :  ->snprintf(4)
#    sdk_remote.c(403) :  ->EVP_impl_sendState(2)
#    sdk_remote.c(397) : <=> (topic)
#        /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(583) : return
#        /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(583) : <=> (elem__tmp)
#    sdk_remote.c(397) : <->EVP_SDK_StateInput_topic(0->return)
#    sdk_remote.c(394) : <=> (state)
#        /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(1033) : return
#        /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(1033) : <=> (elem__tmp)
#    sdk_remote.c(394) : <->EVP_SDK_Request_body(0->return)
#    sdk_remote.c(952) :  ->process_send_state(1)
#    sdk_remote.c(909) : <=> (req)
#        /__w/wedge-agent/wedge-agent/include/sdkenc/sdk_reader.h(1031) : return
#    sdk_remote.c(909) : <->EVP_SDK_Request_as_root(0->return)
#    sdkrpc/server.c(96) :  ->sdk_process_request(0)
#    sdkrpc/server.c(85) : <- readall(1)
#    ioutil.c(22) : <- read(1)
263E550BDAD8048B7714327862E5FA4B

# Seemingly false-positive
# The buffer is big enough to store any possible values of uint16_t
# formatted with %u.
#
# [49E2F8669E0CDA04E99B662813ABB735 : high : String Termination Error : dataflow ]
# webclient/webclient.c(1645) :  ->snprintf(3)
#     webclient/webclient.c(1434) :  ->webclient_perform(0->tunnel_target_port)
#         webclient/webclient.c(1340) : <=> (ws->tunnel)
#     webclient/webclient.c(1351) :  (ws->tunnel->tunnel_target_port)
#     webclient/webclient.c(1351) : <=> (tunnel->tunnel_target_port)
#             webclient/webclient.c(555) : <=> (targ->port)
#                 netlib/netlib_parseurl.c(173) : <=> (url->port)
#                 netlib/netlib_parseurl.c(169) : <=> (accum)
#                 netlib/netlib_parseurl.c(165) : <=> (src)
#                 netlib/netlib_parseurl.c(127) : <=> (src)
#                 netlib/netlib_parseurl.c(120) : <=> (src)
#                 netlib/netlib_parseurl.c(113) : <=> (src)
#                 netlib/netlib_parseurl.c(60) : <=> (src)
#             webclient/webclient.c(531) : <->netlib_parseurl(0->1->port)
#         webclient/webclient.c(709) : <->parseurl(0->1->port)
#         webclient/webclient.c(579) : <=> (ws->line[])
#     webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.port)
#     webclient/webclient.c(1836) : <- blob_file_read_func(0)
#     blob_put.c(32) : <- read(1)
49E2F8669E0CDA04E99B662813ABB735

# False positive.
# While it is true the stream name is retrieved from the outside world,
# flatcc already ensures a valid string has been created beforehand.
# [9E652DB5145BD397905E12E17A863CB9 : high : String Termination Error : dataflow ]
# module_instance.c(414) :  ->strcmp(1)
#     sdk_remote.c(916) :  ->module_instance_stream_from_name(1)
#     sdk_remote.c(909) : <=> (name)
#         sdkenc/sdk_reader.h(1164) : return
#         sdkenc/sdk_reader.h(1164) : <=> (elem__tmp)
#     sdk_remote.c(909) : <->EVP_SDK_StreamParamsRequest_name(0->return)
#     sdk_remote.c(903) : <=> (t)
#         sdkenc/sdk_reader.h(1104) : return
#         sdkenc/sdk_reader.h(1104) : <=> (elem__tmp)
#     sdk_remote.c(903) : <->EVP_SDK_Request_body(0->return)
#     sdk_remote.c(982) :  ->process_stream_params_request(1)
#     sdk_remote.c(939) : <=> (req)
#         sdkenc/sdk_reader.h(1102) : return
#     sdk_remote.c(939) : <->EVP_SDK_Request_as_root(0->return)
#     sdkrpc/server.c(96) :  ->sdk_process_request(0)
#     sdkrpc/server.c(85) : <- readall(1)
#     ioutil.c(22) : <- read(1)
9E652DB5145BD397905E12E17A863CB9

##########################################################
# Filtering Race Condition - File System Access          #
##########################################################
# We only use stat to identify if the reference is a directory.
# Anyway, if some unrelated programs can access the directory,
# it's a deployment issue.

#[2E2A2BBA83117F6143066B4645BE52E3 : high : Race Condition : File System Access : controlflow ]
#
#    fsutil.c(41) : Branch not taken: (dir != NULL)
#    fsutil.c(49) : Branch not taken: (d != NULL)
#    fsutil.c(52) : Branch not taken: (strcmp(d->d_name, "..") != 0)
#    fsutil.c(52) : Branch not taken: (strcmp(d->d_name, ".") != 0)
#    fsutil.c(57) : Branch taken: (dtype == 0)
#    fsutil.c(60) : start -> s : stat(dname, &(st))
#    fsutil.c(60) : s -> s : st refers to the stat structure for dname
#    fsutil.c(61) : Branch not taken: (ret != -1)
#    fsutil.c(64) : s -> check : st : Symbolic filename dname used to check some file property
#    fsutil.c(68) : Branch taken: (dtype == 4)
#    fsutil.c(70) : check -> use : rmtree(dname) : Symbolic filename dname used to operate on a file
#        fsutil.c(40) : check -> use : opendir(name) : Symbolic filename name used to operate on a file
2E2A2BBA83117F6143066B4645BE52E3

#[62EB68D06263ED34644F50C9B5277B2F : high : Race Condition : File System Access : controlflow ]
#
#    fsutil.c(41) : Branch not taken: (dir != NULL)
#    fsutil.c(49) : Branch not taken: (d != NULL)
#    fsutil.c(52) : Branch not taken: (strcmp(d->d_name, "..") != 0)
#    fsutil.c(52) : Branch not taken: (strcmp(d->d_name, ".") != 0)
#    fsutil.c(57) : Branch taken: (dtype == 0)
#    fsutil.c(60) : start -> s : stat(dname, &(st))
#    fsutil.c(60) : s -> s : st refers to the stat structure for dname
#    fsutil.c(61) : Branch not taken: (ret != -1)
#    fsutil.c(64) : s -> check : st : Symbolic filename dname used to check some file property
#    fsutil.c(68) : Branch not taken: (dtype != 4)
#    fsutil.c(72) : check -> use : unlink(dname) : Symbolic filename dname used to operate on a file
62EB68D06263ED34644F50C9B5277B2F

# The agent assumes the exclusive access to the directory.
# When the agent creates the directory, it uses mask 0700.
#
# [9E37052C50DB7EE2DD86293C47F63E84 : high : Race Condition : File System Access : controlflow ]
#
#     libevp-agent/persist.c(70) : Branch not taken: (ret != -1)
#     libevp-agent/persist.c(77) : start -> o2 : open(tmp_name, ...) : Symbolic filename tmp_name used to open a file
#     libevp-agent/persist.c(78) : Branch not taken: (fd >= 0)
#     libevp-agent/persist.c(85) : Branch not taken: (ssz == sz)
#     libevp-agent/persist.c(93) : Branch not taken: (ret == 0)
#     libevp-agent/persist.c(100) : Branch not taken: (ret == 0)
#     libevp-agent/persist.c(106) : o2 -> use : rename(tmp_name, ...) : Symbolic filename tmp_name used to operate on a file
9E37052C50DB7EE2DD86293C47F63E84

# False positive
# Rationale:
# Fortify is concerned about methods working with files (unlink, open, ...)
# because an user can pass a filename of restricted area (like ../../)
# But, in our case the code is working with module files, and there is not any
# user input
# Filename is created by module_path, and there is no user input, so the paths
# are well known


##########################################################
# Filtering Format String issues                         #
# high : Format String : dataflow                        #
##########################################################
# on these, fmt is carried ofer from the functions arguments
# it is expected to be a formatting string.
# I understand in this case, we are passing static format strings
# (defined by ourselves in the code). So there is nothing
# Fortify should be complaining about.
#
# More info on: https://vulncat.fortify.com/en/detail?id=desc.dataflow.cpp.format_string
#
# [ADE6C4240E76BC93EF5987BD55252182 : high : Format String : dataflow ]
# libevp-agent/util.c(282) :  ->vasprintf(1)
#     libevp-agent/blob.c(252) :  ->xasprintf_internal(4)
#     libevp-agent/blob.c(242) : <=> (proxy_host)
#     libevp-agent/blob.c(242) : <- config_get_string(return)
#     libevp-agent/config.c(211) : return (val)
#     libevp-agent/config.c(209) : <=> (val)
#         libevp-agent/util.c(231) : return (cp)
#         libevp-agent/util.c(227) : <=> (cp)
#         libevp-agent/util.c(227) : <->strdup(0->return)
#     libevp-agent/config.c(209) : <->xstrdup_internal(2->return)
#     libevp-agent/config.c(201) : <- load_config(1)
#     libevp-agent/config.c(56) : <- config_load_pk_file(1)
#     libevp-agent/config_pk_file.c(90) : <=> (vpp)
#     libevp-agent/config_pk_file.c(84) : taint change {+NULL_TERMINATED-NOT_NULL_TERMINATED,-NOT_NULL_TERM_TRUNCATE}
#     libevp-agent/config_pk_file.c(77) : <- fread(0)
ADE6C4240E76BC93EF5987BD55252182

# [2A0E499555622CD9A4D09618DD67689E : high : Format String : dataflow ]
# libevp-agent/xlog.c(53) :  ->vfprintf(1)
#     libevp-agent/xlog.c(205) :  ->vxlog(1)
#     libevp-agent/platform.c(90) :  ->xlog(3)
#     libevp-agent/xlog.c(226) :  ->plat_xlog(3)
#     libevp-agent/docker.c(500) :  ->xxlog_print(5)
#     libevp-agent/docker.c(474) : <=> (db)
#     libevp-agent/docker.c(474) : <- config_get_string(return)
#     libevp-agent/config.c(211) : return (val)
#     libevp-agent/config.c(209) : <=> (val)
#         libevp-agent/util.c(231) : return (cp)
#         libevp-agent/util.c(227) : <=> (cp)
#         libevp-agent/util.c(227) : <->strdup(0->return)
#     libevp-agent/config.c(209) : <->xstrdup_internal(2->return)
#     libevp-agent/config.c(201) : <- load_config(1)
#     libevp-agent/config.c(56) : <- config_load_pk_file(1)
#     libevp-agent/config_pk_file.c(90) : <=> (vpp)
#     libevp-agent/config_pk_file.c(84) : taint change {+NULL_TERMINATED-NOT_NULL_TERMINATED,-NOT_NULL_TERM_TRUNCATE}
#     libevp-agent/config_pk_file.c(77) : <- fread(0)
2A0E499555622CD9A4D09618DD67689E

# False positive. The use of vsprintf() in this context is safe, because
# it is determined by a prior call to vsnprintf(0, NULL, ...).
# [0E2416F2B8371EDB964BE715085019E7 : critical : STM-117(17th edition)Linux : Using restricted function group 2 : semantic ]
# module.c(355) : vsprintf()
0E2416F2B8371EDB964BE715085019E7

#[22A742EDD5C9FE68A83BB951F20CD7CE : high : Format String : dataflow ]
#xlog.c(49) :  ->vfprintf(1)
#    xlog.c(198) :  ->vxlog(1)
#    xlog.c(218) :  ->xxlog_vprint(3)
#    webclient/webclient.c(1296) :  ->xxlog_print(4)
#                netlib/netlib_parseurl.c(90) :  (url->scheme)
#                netlib/netlib_parseurl.c(90) : <=> (dest)
#                netlib/netlib_parseurl.c(60) : <=> (src)
#            webclient/webclient.c(531) : <->netlib_parseurl(0->1->scheme)
#        webclient/webclient.c(709) : <->parseurl(0->1->scheme)
#        webclient/webclient.c(579) : <=> (ws->line[])
#    webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.scheme)
#    webclient/webclient.c(1836) : <- blob_file_read_func(0)
#    blob_put.c(32) : <- read(1)
#
#    timeutil.c(80) : start -> allocated : localtime_r(...) : localtime_r may return NULL
#    timeutil.c(80) : allocated -> used : localtime_r((&now.tv_sec), (&ltime)) : return value used without null check
#
#    sdk.c(201) : Branch taken: (h != NULL)
#    sdk.c(201) : Branch taken: (h->exiting == 0)
#    sdk.c(203) : start -> defined : Declaration of config
#    sdk.c(212) : Branch taken: (event != NULL)
#    sdk.c(213) : defined -> used : config : Variable config used without being initialized
#
#    blob_get.c(52) : Branch taken: (wk->tmpname_template != NULL)
#    blob_get.c(54) : Branch not taken: (last_delim != NULL)
#    blob_get.c(62) : Branch not taken: (ret != -1)
#    blob_get.c(64) : Branch not taken: (ret < 4096)
#    blob_get.c(69) : start -> mkstempState : mkstemp(...)
22A742EDD5C9FE68A83BB951F20CD7CE

# [667AEA5F112CC537255CDA0573C0AFEA : high : Format String : dataflow ]
# xlog.c(53) :  ->vfprintf(1)
#     xlog.c(198) :  ->vxlog(1)
#     platform.c(90) :  ->xlog(3)
#     xlog.c(219) :  ->plat_xlog(3)
#     module_instance_impl_docker.c(364) :  ->xxlog_print(4)
#     module_instance_impl_docker.c(361) : <=> (module_instance_dir_for_dockerd)
#     module_instance_impl_docker.c(362) : <- getenv(return)
667AEA5F112CC537255CDA0573C0AFEA

#[484BFD7B0ACA9A1A0A78EC7A87F50FD1 : high : Format String : dataflow ]
#xlog.c(49) :  ->vfprintf(1)
#    xlog.c(198) :  ->vxlog(1)
#    xlog.c(218) :  ->xxlog_vprint(3)
#    webclient/webclient.c(1296) :  ->xxlog_print(4)
#                netlib/netlib_parseurl.c(90) :  (url->scheme)
#                netlib/netlib_parseurl.c(90) : <=> (dest)
#                netlib/netlib_parseurl.c(60) : <=> (src)
#            webclient/webclient.c(531) : <->netlib_parseurl(0->1->scheme)
#        webclient/webclient.c(709) : <->parseurl(0->1->scheme)
#        webclient/webclient.c(579) : <=> (ws->line[])
#    webclient/webclient.c(1972) : <->wget_parseheaders(1->buffer[]->1->target.scheme)
#    webclient/webclient.c(1916) : <- webclient_conn_recv(1)
#    webclient/webclient.c(1115) : <- recv(1)
484BFD7B0ACA9A1A0A78EC7A87F50FD1

# The string formatting funtion here is safe with respect to the
# vulnerability explained at https://vulncat.fortify.com/en/detail?id=desc.dataflow.cpp.format_string#C%2fC%2b%2b
# [FF2460025322E3F4AF97422E8092092D : high : Format String : dataflow ]
# libevp-agent/util.c(282) :  ->vasprintf(1)
#     libevp-agent/docker.c(523) :  ->xasprintf_internal(4)
#     libevp-agent/docker.c(477) : <=> (auth)
#     libevp-agent/docker.c(477) : <- get_registry_auth_header_old(return)
#     libevp-agent/docker.c(464) : return (token)
#     libevp-agent/docker.c(450) : <=> (token)
#     libevp-agent/docker.c(450) : <- getenv(return)
FF2460025322E3F4AF97422E8092092D

# The string formatting funtion here is safe with respect to the
# vulnerability explained at https://vulncat.fortify.com/en/detail?id=desc.dataflow.cpp.format_string#C%2fC%2b%2b
#[FDEE81E625A26EA5391FD87DEBA27709 : high : Format String : dataflow ]
#libevp-agent/util.c(294) :  ->vasprintf(1)
#    libevp-agent/path.c(57) :  ->xasprintf_internal(4)
#    libevp-agent/evp_agent.c(183) :  ->path_init(0)
#    libevp-agent/evp_agent.c(183) : <- getenv(return)
FDEE81E625A26EA5391FD87DEBA27709

# The string formatting funtion here is safe with respect to the
# vulnerability explained at https://vulncat.fortify.com/en/detail?id=desc.dataflow.cpp.format_string#C%2fC%2b%2b
# the inputs to this call are internally generated (module instance names)
#[7956BF50B29C360112D9F17AD0EBF9E7 : high : Format String : dataflow ]
#libevp-agent/util.c(294) :  ->vasprintf(1)
#    libevp-agent/fsutil.c(56) :  ->xasprintf_internal(5)
#    libevp-agent/fsutil.c(45) : <=> (d)
#    libevp-agent/fsutil.c(45) : <- readdir(return)
7956BF50B29C360112D9F17AD0EBF9E7

# The string formatting funtion here is safe with respect to the
# vulnerability explained at https://vulncat.fortify.com/en/detail?id=desc.dataflow.cpp.format_string#C%2fC%2b%2b
# the inputs to this call are internally generated (module instance names)
# [0709333D0A0653551E5A1C82D680A035 : high : Format String : dataflow ]
# util.c(282) :  ->vasprintf(1)
#     module_instance_impl_docker.c(175) :  ->xasprintf_internal(4)
#     module_instance_impl_docker.c(175) :  (module_instance_dir_for_dockerd)
#     module_instance_impl_docker.c(361) : <=> (module_instance_dir_for_dockerd)
#     module_instance_impl_docker.c(362) : <- getenv(return)
0709333D0A0653551E5A1C82D680A035

# False positive. xlog is a printf(3)-like function.
# [71CB3EE613746CDEB2162E0BCAE79E17 : high : Format String : dataflow ]
# libevp-agent/util.c(282) :  ->vasprintf(1)
#     libevp-agent/platform.c(417) :  ->xasprintf_internal(5)
#     libevp-agent/platform.c(403) : <=> (name)
#     libevp-agent/platform.c(402) : <=> (d)
#     libevp-agent/platform.c(402) : <- readdir(return)
71CB3EE613746CDEB2162E0BCAE79E17

# [5D3ECAD28F500C838012363D315B43C5 : high : Format String : dataflow ]
# libevp-agent/xlog.c(53) :  ->vfprintf(1)
#     libevp-agent/xlog.c(205) :  ->vxlog(1)
#     libevp-agent/platform.c(90) :  ->xlog(3)
#     libevp-agent/xlog.c(226) :  ->plat_xlog(3)
#     libevp-agent/platform.c(408) :  ->xxlog_print(4)
#     libevp-agent/platform.c(403) : <=> (name)
#     libevp-agent/platform.c(402) : <=> (d)
#     libevp-agent/platform.c(402) : <- readdir(return)
5D3ECAD28F500C838012363D315B43C5

# Loaded libraries are not expected to be unloaded, and at the end of
# the function we are sure that the library is correct
#
#[877C3C909AFDE5BA7AAF185E751A0B9C : high : Unreleased Resource : controlflow ]
#
#   module_api_wasm.c(88) : start -> loaded : hdl = dlopen(...)
#   module_api_wasm.c(88) : loaded -> loaded : hdl refers to an open file descriptor
#   module_api_wasm.c(89) : Branch not taken: (hdl != 0)
#   module_api_wasm.c(95) : Branch not taken: (fun != 0)
#   module_api_wasm.c(99) : loaded -> loaded : hdl no longer refers to an open file descriptor
#   module_api_wasm.c(99) : loaded -> end_of_scope : hdl end scope : File descriptor leaked
877C3C909AFDE5BA7AAF185E751A0B9C

# The memory allocated for m->moduleId is freed by module_instance_stop1(m)
# [6F91371E16CF5688E969E4128BC4B81E : high : Memory Leak : controlflow ]
#
#     module_instance.c(369) : Branch not taken: (m != NULL)
#     module_instance.c(373) : Branch taken: module_instance_is_persistent(m)
#     module_instance.c(377) : start -> allocated : m->moduleId = xstrdup_internal(...)
#         util.c(221) : start -> allocated : cp = strdup(...)
#         util.c(221) : allocated -> allocated : cp refers to dynamically allocated memory
#         util.c(222) : Branch not taken: (cp != NULL)
#         util.c(225) : allocated -> allocated : return
#     module_instance.c(377) : allocated -> allocated : m->moduleId refers to dynamically allocated memory
#     module_instance.c(380) : allocated -> allocated : m->moduleId no longer refers to dynamically allocated memory
#     module_instance.c(380) : allocated -> leak : m end scope : Memory leaked
6F91371E16CF5688E969E4128BC4B81E

# [54E5C19987CBAFDEBC3032B43022A4A8 : high : Memory Leak : controlflow ]
#
#     module_log_cap.c(228) : start -> allocated : ctxt.rw->fds = xrealloc_internal(...)
#         util.c(207) : Branch taken: (sz != 0)
#         util.c(208) : start -> allocated : vp = realloc(...)
#         util.c(208) : allocated -> allocated : vp refers to dynamically allocated memory
#         util.c(210) : Branch not taken: (sz != 0)
#         util.c(210) : Branch not taken: (vp != NULL)
#         util.c(215) : allocated -> allocated : return
#     module_log_cap.c(228) : allocated -> allocated : ctxt.rw->fds refers to dynamically allocated memory
#     module_log_cap.c(235) : allocated -> allocated : ctxt.rw->fds no longer refers to dynamically allocated memory
#     module_log_cap.c(235) : allocated -> leak : ctxt end scope : Memory leaked
54E5C19987CBAFDEBC3032B43022A4A8

# False positive.
# Memory allocated in this context is being freed when the object is being garbage collected on close or stop.
#
# [BCE4660FB95F77677A39E318796E567B : high : Memory Leak : controlflow ]
#
#     libevp-agent/module_log_cap.c(319) : Branch not taken: (rv == 0)
#     libevp-agent/module_log_cap.c(325) : start -> allocated : <AnonymousObject>.instance_id.rw = strdup(...)
#     libevp-agent/module_log_cap.c(325) : allocated -> allocated : <AnonymousObject>.instance_id.rw refers to dynamically allocated memory
#     libevp-agent/module_log_cap.c(340) : allocated -> allocated : <AnonymousObject>.instance_id.rw no longer refers to dynamically allocated memory
#     libevp-agent/module_log_cap.c(340) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
BCE4660FB95F77677A39E318796E567B

# The platform function mod_fs_file_munmap should free the handle if it has been allocated by mod_fs_file_mmap.
# Fortify can't figure out that we didn't call evp_agent_platform_register anywhere.
# So if the functions are not provided, there is no way we take the branch (g_platform.mod_fs_file_munmap != 0)
# [0502869A4F4CEAF07772DF9E8D0BB9AF : high : Memory Leak : controlflow ]
#
#     module_impl_wasm.c(65) : start -> allocated : wasm_module_mmap_handle = plat_mod_fs_file_mmap(...)
#         platform.c(110) : Branch not taken: (g_platform.mod_fs_file_mmap == 0)
#         platform.c(119) : Branch not taken: (filename != NULL)
#         platform.c(126) : Branch not taken: (fd != -1)
#         platform.c(139) : Branch not taken: (fstat(fd, (&sb)) != -1)
#         platform.c(149) : Branch not taken: (addr != -1)
#         platform.c(155) : start -> allocated : handle = malloc(...)
#         platform.c(155) : allocated -> allocated : handle refers to dynamically allocated memory
#         platform.c(156) : Branch not taken: (handle != NULL)
#         platform.c(167) : allocated -> allocated : ret refers to dynamically allocated memory
#         platform.c(168) : goto
#         platform.c(183) : allocated -> allocated : return
#     module_impl_wasm.c(65) : allocated -> allocated : wasm_module_mmap_handle refers to dynamically allocated memory
#     module_impl_wasm.c(68) : Branch taken: (wasm_module_mmap_handle != NULL)
#     module_impl_wasm.c(75) : allocated -> allocated : plat_mod_fs_file_munmap(wasm_module_mmap_handle)
#         platform.c(187) : allocated -> allocated : handle refers to dynamically allocated memory
#         platform.c(189) : Branch taken: (g_platform.mod_fs_file_munmap != 0)
#         platform.c(190) : allocated -> allocated : return
#     module_impl_wasm.c(84) : allocated -> allocated : wasm_module_mmap_handle no longer refers to dynamically allocated memory
#     module_impl_wasm.c(84) : allocated -> leak : wasm_module_mmap_handle end scope : Memory leaked
0502869A4F4CEAF07772DF9E8D0BB9AF

# Same as previous
# [2BAD3D7455BD71F076D04C55DA0D2D00 : high : Memory Leak : controlflow ]
#
#     hash.c(33) : Branch not taken: (info != NULL)
#     hash.c(39) : Branch not taken: (ref_len == byte_size)
#     hash.c(44) : Branch not taken: (calc != 0)
#     hash.c(54) : start -> allocated : handle = plat_mod_fs_file_mmap(...)
#         platform.c(109) : Branch not taken: (g_platform.mod_fs_file_mmap == 0)
#         platform.c(118) : Branch not taken: (filename != NULL)
#         platform.c(125) : Branch not taken: (fd != -1)
#         platform.c(138) : Branch not taken: (fstat(fd, (&sb)) != -1)
#         platform.c(148) : Branch not taken: (addr != -1)
#         platform.c(154) : start -> allocated : handle = malloc(...)
#         platform.c(154) : allocated -> allocated : handle refers to dynamically allocated memory
#         platform.c(155) : Branch not taken: (handle != NULL)
#         platform.c(166) : allocated -> allocated : ret refers to dynamically allocated memory
#         platform.c(167) : goto
#         platform.c(182) : allocated -> allocated : return
#     hash.c(54) : allocated -> allocated : handle refers to dynamically allocated memory
#     hash.c(55) : Branch not taken: (handle != NULL)
#     hash.c(60) : allocated -> allocated : plat_mod_fs_file_munmap(handle)
#         platform.c(186) : allocated -> allocated : handle refers to dynamically allocated memory
#         platform.c(188) : Branch taken: (g_platform.mod_fs_file_munmap != 0)
#         platform.c(189) : allocated -> allocated : return
#     hash.c(63) : goto
#     hash.c(113) : allocated -> allocated : handle no longer refers to dynamically allocated memory
#     hash.c(113) : allocated -> leak : handle end scope : Memory leaked
2BAD3D7455BD71F076D04C55DA0D2D00

# False positive.
# When pthread_mutex_lock fails, it does not need to be unlocked again.
# However, Fortify incorrectly thinks that pthread_mutex_lock allocates
# resources that must be released.
# [72C5DE11CA2C2404081551D2949E1364 : high : Unreleased Resource : Synchronization : controlflow ]
#
#     stream/posix.c(777) : start -> loaded : pthread_mutex_lock((&list->mutex))
#     stream/posix.c(777) : loaded -> loaded : (&list->mutex) refers to an allocated resource
#     stream/posix.c(779) : Branch taken: (error != 0)
#     stream/posix.c(782) : goto
#     stream/posix.c(822) : loaded -> loaded : (&list->mutex) no longer refers to an allocated resource
#     stream/posix.c(822) : loaded -> end_of_scope : list end scope : Resource leaked
72C5DE11CA2C2404081551D2949E1364

# False positive. Same as 72C5DE11CA2C2404081551D2949E1364.
# [BD3EAC79A8C2D897A85DCB7BEDCF248B : high : Unreleased Resource : Synchronization : controlflow ]
#
#     stream/posix.c(830) : start -> loaded : pthread_mutex_lock((&list->mutex))
#     stream/posix.c(830) : loaded -> loaded : (&list->mutex) refers to an allocated resource
#     stream/posix.c(832) : Branch taken: (error != 0)
#     stream/posix.c(835) : goto
#     stream/posix.c(873) : loaded -> loaded : (&list->mutex) no longer refers to an allocated resource
#     stream/posix.c(873) : loaded -> end_of_scope : list end scope : Resource leaked
BD3EAC79A8C2D897A85DCB7BEDCF248B

# False positive. Same as 72C5DE11CA2C2404081551D2949E1364.
# [47898DAC88483CB0AD165FBA72F21AFC : high : Unreleased Resource : Synchronization : controlflow ]
#
#     stream/posix.c(1122) : start -> loaded : pthread_mutex_lock((&list->mutex))
#     stream/posix.c(1122) : loaded -> loaded : (&list->mutex) refers to an allocated resource
#     stream/posix.c(1125) : Branch taken: (error != 0)
#     stream/posix.c(1128) : goto
#     stream/posix.c(1179) : loaded -> loaded : (&list->mutex) no longer refers to an allocated resource
#     stream/posix.c(1179) : loaded -> end_of_scope : list end scope : Resource leaked
47898DAC88483CB0AD165FBA72F21AFC

# False positive.
# Yet again, Fortify fails to see the ownership for dup is transferred
# to req when the function is successful.
# [BA0F36F9B53D08073B3E0230D7DE21EB : high : Memory Leak : controlflow ]
#
#     stream/posix.c(1092) : start -> allocated : dup = malloc(...)
#     stream/posix.c(1092) : allocated -> allocated : dup refers to dynamically allocated memory
#     stream/posix.c(1094) : Branch not taken: (req != NULL)
#     stream/posix.c(1100) : Branch not taken: (dup != NULL)
#     stream/posix.c(1106) : allocated -> allocated : dup refers to dynamically allocated memory
#     stream/posix.c(1109) : allocated -> allocated : return
#     stream/posix.c(1109) : allocated -> allocated : dup no longer refers to dynamically allocated memory
#     stream/posix.c(1109) : allocated -> allocated : <AnonymousObject>.buf no longer refers to dynamically allocated memory
#     stream/posix.c(1109) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
BA0F36F9B53D08073B3E0230D7DE21EB

# False positive.
# Yet again, Fortify fails to see the ownership for hostnamedup is transferred
# to params.posix when the function is succesful.
# [74169ED2AA3FB0795C28912A9E687D77 : high : Memory Leak : controlflow ]
#
#     stream/stream.c(477) : Branch not taken: (namedup != NULL)
#     stream/stream.c(487) : Branch taken: (src->type == 1)
#     stream/stream.c(487) : goto
#     stream/stream.c(491) : start -> allocated : hostnamedup = strdup(...)
#     stream/stream.c(491) : allocated -> allocated : hostnamedup refers to dynamically allocated memory
#     stream/stream.c(492) : Branch not taken: (hostnamedup != NULL)
#     stream/stream.c(501) : allocated -> allocated : hostnamedup refers to dynamically allocated memory
#     stream/stream.c(505) : allocated -> allocated : hostnamedup no longer refers to dynamically allocated memory
#     stream/stream.c(520) : Branch not taken: (ret == 0)
#     stream/stream.c(525) : allocated -> allocated : hostnamedup no longer refers to dynamically allocated memory
#     stream/stream.c(525) : allocated -> leak : hostnamedup end scope : Memory leaked
74169ED2AA3FB0795C28912A9E687D77

# Not an issue.
# Even if the data type for sr->id is defined as EVP_STREAM_PEER_ID,
# assigning fd (an int) to it is not a problem, as EVP_STREAM_PEER_ID are
# meant as opaque identifiers for users.
# [B4D4885FB1057A4F2A586BA9DFB6B7E6 : high : Type Mismatch : Signed to Unsigned : structural ]
#     libevp-agent/stream/posix.c(392)
#     FieldAccess: <AnonymousObject>.id [libevp-agent/stream/posix.c(392)]
#     VariableAccess: fd [libevp-agent/stream/posix.c(393)]
B4D4885FB1057A4F2A586BA9DFB6B7E6

# False positive.
# Yet again, Fortify fails to see that n >= 0 is checked before it is
# assigned to sr->n. Therefore, there is no risk on this assignment.
# [2C030A9231E2837C9C4BD4320CA6A61E : high : Type Mismatch : Signed to Unsigned : structural ]
#     libevp-agent/stream/posix.c(436)
#     FieldAccess: <AnonymousObject>.n [libevp-agent/stream/posix.c(436)]
#     VariableAccess: n [libevp-agent/stream/posix.c(437)]
2C030A9231E2837C9C4BD4320CA6A61E

# False positive.
# These symbols are related to the glibc implementation for
# pthread_cleanup_push(3) and pthread_cleanup_pop(3), which are defined as
# macros by glibc (this is allowed behaviour according to POSIX). Inside the
# implementation for pthread_cleanup_push(3), glibc inserts the following
# branch:
#
#	if (__builtin_expect((__not_first_call), 0)) {
#		__cancel_routine(__cancel_arg);
#		__pthread_unwind_next(&__cancel_buf);
#	}
#
# However, Fortify fails to see __pthread_unwind_next has the non-standard
# __attribute__((__noreturn__)). Therefore, it is impossible that the goto
# statement pointed out by Fortify is executed, and thus there is no risk for
# a double-free condition.
# [AB82561AD6FCF66BC65E7AFFCCBCC835 : high : Double Free : controlflow ]
#
#     libevp-agent/stream/stream.c(394) : Branch taken: __not_first_call
#     libevp-agent/stream/stream.c(394) : nofree -> free : free(__cancel_arg)
#     libevp-agent/stream/stream.c(394) : free -> free : Pointer __cancel_arg refers to a freed memory allocation
#     libevp-agent/stream/stream.c(399) : goto
#     libevp-agent/stream/stream.c(404) : free -> doublefree : free(__cancel_arg) : Pointer __cancel_arg freed a second time
AB82561AD6FCF66BC65E7AFFCCBCC835

# False positive. Similar to AB82561AD6FCF66BC65E7AFFCCBCC835.
# [53786A8C3E915B54DB96ECC8DF3FFCF8 : high : Double Free : controlflow ]
#
#     libevp-agent/stream/posix.c(407) : Branch taken: __not_first_call
#     libevp-agent/stream/posix.c(407) : nofree -> free : free(__cancel_arg)
#     libevp-agent/stream/posix.c(407) : free -> free : Pointer __cancel_arg refers to a freed memory allocation
#     libevp-agent/stream/posix.c(412) : goto
#     libevp-agent/stream/posix.c(442) : Branch taken: (ret != 0)
#     libevp-agent/stream/posix.c(442) : free -> doublefree : free(__cancel_arg) : Pointer __cancel_arg freed a second time
53786A8C3E915B54DB96ECC8DF3FFCF8

# Fortify thinks g_platform.secure_malloc can be changed between calls to load_config.
# Since platform should be registered before evp_agent_start, this cannot happen.
# [676F4C99CFB6AE0983D085FA5B8BE112 : high : Memory Leak : controlflow ]
#
#     libevp-agent/tls.c(300) : Branch not taken: (cfg != NULL)
#     libevp-agent/tls.c(303) : Branch not taken: (load_config(cfg, (&buf), (&buflen)) == 0)
#     libevp-agent/tls.c(306) : start -> allocated : pk = plat_secure_malloc(...)
#         libevp-agent/platform.c(469) : Branch not taken: (g_platform.secure_malloc == 0)
#         libevp-agent/platform.c(472) : start -> allocated : malloc(...)
#         libevp-agent/platform.c(472) : allocated -> allocated : return
#     libevp-agent/tls.c(306) : allocated -> allocated : pk refers to dynamically allocated memory
#     libevp-agent/tls.c(306) : Branch not taken: (pk != NULL)
#     libevp-agent/tls.c(316) : Branch taken: (rv != 0)
#     libevp-agent/tls.c(317) : goto
#     libevp-agent/tls.c(326) : allocated -> allocated : plat_secure_free(pk)
#         libevp-agent/platform.c(476) : allocated -> allocated : ptr refers to dynamically allocated memory
#         libevp-agent/platform.c(478) : Branch taken: (g_platform.secure_malloc != 0)
#         libevp-agent/platform.c(478) : Branch taken: (g_platform.secure_free != 0)
#         libevp-agent/platform.c(480) : allocated -> allocated : return
#     libevp-agent/tls.c(332) : allocated -> allocated : pk no longer refers to dynamically allocated memory
#     libevp-agent/tls.c(332) : allocated -> leak : pk end scope : Memory leaked
676F4C99CFB6AE0983D085FA5B8BE112

# False positive.
# Fortify does not understand the semantics behind pthread_cleanup_push(3)
# and pthread_cleanup_pop(3). When connect(2) fails, pthread_cleanup_pop(3)
# would be executed since ret < 0. Then, cleanup_fd, the cleanup handler,
# would close(2) the file descriptor accordingly, thus removing the risk for
# a memory leak.
# [5E1F68254BB80CAF7CE14E355E5B26F3 : high : Unreleased Resource : controlflow ]
#
#     stream/posix.c(716) : start -> loaded : fd = socket(...)
#     stream/posix.c(716) : loaded -> loaded : fd refers to an open file descriptor
#     stream/posix.c(720) : Branch not taken: (fd >= 0)
#     stream/posix.c(726) : Branch taken: (connect(fd, ai->ai_addr, ai->ai_addrlen) != 0)
#     stream/posix.c(729) : goto
#     stream/posix.c(736) : loaded -> loaded : fd no longer refers to an open file descriptor
#     stream/posix.c(736) : loaded -> end_of_scope : fd end scope : File descriptor leaked
5E1F68254BB80CAF7CE14E355E5B26F3

# False positive.
# Fortify is too smart (more like too stupid) and thinks that defining
# keys on a key-value dictionary with a field called "key" necessarily means
# that encryption keys are being hardcoded and therefore exposed.
# That said, a serious tool should never flag this.
# [29D24C3C2AA04CFBB8C2D8FBAEE45120 : high : Key Management : Hardcoded Encryption Key : structural ]
#     libevp-agent/blob_type_evp_rpc.c(244)
#     Field: entry::key [libevp-agent/blob_type_evp_rpc.c(243)]
29D24C3C2AA04CFBB8C2D8FBAEE45120

# False positive.
# Same as 29D24C3C2AA04CFBB8C2D8FBAEE45120.
# [6A72579B5D0E66D639B8AE2241F2187A : high : Key Management : Hardcoded Encryption Key : structural ]
#     libevp-agent/blob_type_evp_rpc.c(244)
#     Field: entry::key [libevp-agent/blob_type_evp_rpc.c(243)]
6A72579B5D0E66D639B8AE2241F2187A

# Intended behaviour as the path must be override by the env
#[C64920CF59AB02CE038282D6A3D54E90 : critical : Path Manipulation : dataflow ]
#libevp-agent/main_loop.c(70) :  ->open(0)
#    libevp-agent/main_loop.c(70) :  (pipe_name)
#    libevp-agent/main_loop.c(107) : <=> (pipe_name)
#    libevp-agent/main_loop.c(107) : <- getenv(return)
C64920CF59AB02CE038282D6A3D54E90

# Intended behaviour as the path must be override by the env
#[B6EA5D109BFEAA89BA2B58FCEAF41E47 : critical : Path Manipulation : dataflow ]
#libevp-agent/main_loop.c(115) :  ->mkfifo(0)
#    libevp-agent/main_loop.c(107) : <=> (pipe_name)
#    libevp-agent/main_loop.c(107) : <- getenv(return)
B6EA5D109BFEAA89BA2B58FCEAF41E47

# Intended behaviour as the path must be override by the env
#[403D3186F37D9B10855059A8D5DDE0AD : critical : Path Manipulation : dataflow ]
#libevp-agent/main_loop.c(119) :  ->open(0)
#    libevp-agent/main_loop.c(107) : <=> (pipe_name)
#    libevp-agent/main_loop.c(107) : <- getenv(return)
403D3186F37D9B10855059A8D5DDE0AD

# If pipe_name is NULL, the execution will abort before xlog being called.
# [2292946D6DF27B0D6C5BFEDE04EBB3DA : high : Format String : dataflow ]
# libevp-agent/xlog.c(53) :  ->vfprintf(1)
#     libevp-agent/xlog.c(205) :  ->vxlog(1)
#     libevp-agent/platform.c(90) :  ->xlog(3)
#     libevp-agent/xlog.c(226) :  ->plat_xlog(3)
#     libevp-agent/main_loop.c(123) :  ->xxlog_print(4)
#     libevp-agent/main_loop.c(105) : <=> (pipe_name)
#     libevp-agent/main_loop.c(105) : <- getenv(return)
2292946D6DF27B0D6C5BFEDE04EBB3DA

# False positive
# Fortify fails to see the ownership for `req` is
# transferred in the call to EVP_impl_blobOperation and blob is
# freed when the request has been handled.
#
# [E87EDCC1CC1D20E52A367A32AED7EDFC : high : Memory Leak : controlflow ]
#
#     sys/SYS_get_blob.c(157) : Branch taken: (strncmp(url, "http://", strlen("http://")) == 0)
#     sys/SYS_get_blob.c(159) : start -> allocated : req = create_http_request(...)
#         sys/SYS_get_blob.c(39) : start -> allocated : ret = EVP_BlobRequestHttpExt_initialize()
#             sdk_common.c(143) : start -> allocated : request = malloc(...)
#             sdk_common.c(143) : allocated -> allocated : request refers to dynamically allocated memory
#             sdk_common.c(145) : Branch taken: (request != 0)
#             sdk_common.c(150) : allocated -> allocated : return
#         sys/SYS_get_blob.c(39) : allocated -> allocated : ret refers to dynamically allocated memory
#         sys/SYS_get_blob.c(39) : Branch not taken: (ret != NULL)
#         sys/SYS_get_blob.c(43) : Branch not taken: (sys_add_headers(ret, headers) == 0)
#         sys/SYS_get_blob.c(48) : Branch not taken: (EVP_BlobRequestHttpExt_setUrl(ret, url) == 0)
#         sys/SYS_get_blob.c(52) : allocated -> allocated : return
#     sys/SYS_get_blob.c(159) : allocated -> allocated : req refers to dynamically allocated memory
#     sys/SYS_get_blob.c(159) : Branch not taken: (req != NULL)
#     sys/SYS_get_blob.c(170) : Branch taken: (urldup == NULL)
#     sys/SYS_get_blob.c(172) : goto
#     sys/SYS_get_blob.c(204) : Branch taken: (req != 0)
#     sys/SYS_get_blob.c(205) : allocated -> allocated : free_request(req, ?)
#         sys/SYS_get_blob.c(87) : allocated -> allocated : req refers to dynamically allocated memory
#         sys/SYS_get_blob.c(94) : Default case
#         sys/SYS_get_blob.c(95) : Default case
#     sys/SYS_get_blob.c(209) : allocated -> allocated : req no longer refers to dynamically allocated memory
#     sys/SYS_get_blob.c(209) : allocated -> leak : req end scope : Memory leaked
#
#     sys/SYS_get_blob.c(157) : Branch taken: (strncmp(url, "http://", strlen("http://")) == 0)
#     sys/SYS_get_blob.c(159) : start -> allocated : req = create_http_request(...)
#         sys/SYS_get_blob.c(39) : start -> allocated : ret = EVP_BlobRequestHttpExt_initialize()
#             sdk_common.c(143) : start -> allocated : request = malloc(...)
#             sdk_common.c(143) : allocated -> allocated : request refers to dynamically allocated memory
#             sdk_common.c(145) : Branch taken: (request != 0)
#             sdk_common.c(150) : allocated -> allocated : return
#         sys/SYS_get_blob.c(39) : allocated -> allocated : ret refers to dynamically allocated memory
#         sys/SYS_get_blob.c(39) : Branch not taken: (ret != NULL)
#         sys/SYS_get_blob.c(43) : Branch not taken: (sys_add_headers(ret, headers) == 0)
#         sys/SYS_get_blob.c(48) : Branch not taken: (EVP_BlobRequestHttpExt_setUrl(ret, url) == 0)
#         sys/SYS_get_blob.c(52) : allocated -> allocated : return
#     sys/SYS_get_blob.c(159) : allocated -> allocated : req refers to dynamically allocated memory
#     sys/SYS_get_blob.c(159) : Branch not taken: (req != NULL)
#     sys/SYS_get_blob.c(170) : Branch not taken: (urldup != NULL)
#     sys/SYS_get_blob.c(175) : Branch not taken: (data != NULL)
#     sys/SYS_get_blob.c(180) : allocated -> allocated : req refers to dynamically allocated memory
#     sys/SYS_get_blob.c(193) : allocated -> allocated : EVP_impl_blobOperation(?, ?, ?, ?, req, ?, ?, ?)
#         sdk.c(1621) : allocated -> allocated : request refers to dynamically allocated memory
#         sdk.c(1629) : Branch taken: (check_blob_type(type) != 0)
#         sdk.c(1631) : goto
#     sys/SYS_get_blob.c(196) : Branch taken: (result != 0)
#     sys/SYS_get_blob.c(198) : goto
#     sys/SYS_get_blob.c(204) : Branch taken: (req != 0)
#     sys/SYS_get_blob.c(205) : allocated -> allocated : free_request(req, ?)
#         sys/SYS_get_blob.c(87) : allocated -> allocated : req refers to dynamically allocated memory
#         sys/SYS_get_blob.c(94) : Default case
#         sys/SYS_get_blob.c(95) : Default case
#     sys/SYS_get_blob.c(209) : allocated -> allocated : req no longer refers to dynamically allocated memory
#     sys/SYS_get_blob.c(209) : allocated -> allocated : <AnonymousObject>.req no longer refers to dynamically allocated memory
#     sys/SYS_get_blob.c(209) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
E87EDCC1CC1D20E52A367A32AED7EDFC

# False positive
# Same as E87EDCC1CC1D20E52A367A32AED7EDFC
#
# [8F4A8873E51A603EE9C1BF1C8449B1B0 : high : Memory Leak : controlflow ]
#
#     sys/SYS_get_blob.c(157) : Branch taken: (strncmp(url, "http://", strlen("http://")) == 0)
#     sys/SYS_get_blob.c(159) : Branch not taken: (req != NULL)
#     sys/SYS_get_blob.c(170) : start -> allocated : urldup = strdup(...)
#     sys/SYS_get_blob.c(170) : allocated -> allocated : urldup refers to dynamically allocated memory
#     sys/SYS_get_blob.c(170) : Branch not taken: (urldup != NULL)
#     sys/SYS_get_blob.c(175) : Branch not taken: (data != NULL)
#     sys/SYS_get_blob.c(180) : allocated -> allocated : urldup refers to dynamically allocated memory
#     sys/SYS_get_blob.c(196) : Branch not taken: (result == 0)
#     sys/SYS_get_blob.c(201) : allocated -> allocated : return
#     sys/SYS_get_blob.c(201) : allocated -> allocated : urldup no longer refers to dynamically allocated memory
#     sys/SYS_get_blob.c(201) : allocated -> allocated : <AnonymousObject>.url no longer refers to dynamically allocated memory
#     sys/SYS_get_blob.c(201) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
8F4A8873E51A603EE9C1BF1C8449B1B0

# False positive
# Same as E87EDCC1CC1D20E52A367A32AED7EDFC
#
# [5D24EB7B0ED0C2262C4380653159A7B9 : high : Memory Leak : controlflow ]
#
#     sys/SYS_get_blob.c(157) : Branch taken: (strncmp(url, "http://", strlen("http://")) == 0)
#     sys/SYS_get_blob.c(159) : Branch not taken: (req != NULL)
#     sys/SYS_get_blob.c(170) : Branch not taken: (urldup != NULL)
#     sys/SYS_get_blob.c(175) : start -> allocated : data = malloc(...)
#     sys/SYS_get_blob.c(175) : allocated -> allocated : data refers to dynamically allocated memory
#     sys/SYS_get_blob.c(175) : Branch not taken: (data != NULL)
#     sys/SYS_get_blob.c(193) : allocated -> allocated : EVP_impl_blobOperation(?, ?, ?, ?, ?, ?, ?, data)
#         sdk.c(1623) : allocated -> allocated : userData refers to dynamically allocated memory
#         sdk.c(1629) : Branch taken: (check_blob_type(type) != 0)
#         sdk.c(1631) : goto
#     sys/SYS_get_blob.c(196) : Branch not taken: (result == 0)
#     sys/SYS_get_blob.c(201) : allocated -> allocated : return
#     sys/SYS_get_blob.c(201) : allocated -> allocated : data no longer refers to dynamically allocated memory
#     sys/SYS_get_blob.c(201) : allocated -> leak : data end scope : Memory leaked
5D24EB7B0ED0C2262C4380653159A7B9

# False positive
# Same as E87EDCC1CC1D20E52A367A32AED7EDFC
#
# [5D24EB7B0ED0C2262C4380653159A7BA : high : Memory Leak : controlflow ]
#
#     sys/SYS_get_blob.c(157) : Branch taken: (strncmp(url, "http://", strlen("http://")) == 0)
#     sys/SYS_get_blob.c(159) : start -> allocated : req = create_http_request(...)
#         sys/SYS_get_blob.c(39) : start -> allocated : ret = EVP_BlobRequestHttpExt_initialize()
#             sdk_common.c(143) : start -> allocated : request = malloc(...)
#             sdk_common.c(143) : allocated -> allocated : request refers to dynamically allocated memory
#             sdk_common.c(145) : Branch taken: (request != 0)
#             sdk_common.c(150) : allocated -> allocated : return
#         sys/SYS_get_blob.c(39) : allocated -> allocated : ret refers to dynamically allocated memory
#         sys/SYS_get_blob.c(39) : Branch not taken: (ret != NULL)
#         sys/SYS_get_blob.c(43) : Branch not taken: (sys_add_headers(ret, headers) == 0)
#         sys/SYS_get_blob.c(48) : Branch not taken: (EVP_BlobRequestHttpExt_setUrl(ret, url) == 0)
#         sys/SYS_get_blob.c(52) : allocated -> allocated : return
#     sys/SYS_get_blob.c(159) : allocated -> allocated : req refers to dynamically allocated memory
#     sys/SYS_get_blob.c(159) : Branch not taken: (req != NULL)
#     sys/SYS_get_blob.c(170) : Branch not taken: (urldup != NULL)
#     sys/SYS_get_blob.c(175) : Branch not taken: (data != NULL)
#     sys/SYS_get_blob.c(180) : allocated -> allocated : req refers to dynamically allocated memory
#     sys/SYS_get_blob.c(193) : allocated -> allocated : EVP_impl_blobOperation(?, ?, ?, ?, req, ?, ?, ?)
#         sdk.c(1621) : allocated -> allocated : request refers to dynamically allocated memory
#         sdk.c(1629) : Branch taken: (check_blob_type(type) != 0)
#         sdk.c(1631) : goto
#     sys/SYS_get_blob.c(196) : Branch not taken: (result == 0)
#     sys/SYS_get_blob.c(201) : allocated -> allocated : return
#     sys/SYS_get_blob.c(201) : allocated -> allocated : req no longer refers to dynamically allocated memory
#     sys/SYS_get_blob.c(201) : allocated -> allocated : <AnonymousObject>.req no longer refers to dynamically allocated memory
#     sys/SYS_get_blob.c(201) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
5D24EB7B0ED0C2262C4380653159A7BA

# False positive
# It is not clear why fortify consider this a type mismatch as it explicitely uses the defined enum values.
#
# [5A4FF5822CDCC8EA9675E94662E38EAD : high : Type Mismatch : Signed to Unsigned : structural ]
#     sys/SYS_get_blob.c(131)
#     Function: to_io_result [sys/SYS_get_blob.c(129)]
5A4FF5822CDCC8EA9675E94662E38EAD


# False positive
# Foritfy is complaining about a pointer not free `data->url` but it is 0
# Our guess it is complainig about AnonymousObject
#
# The 2nd branch complains when the malloc is ok. In this case the url is freed in the callback
#
# [EA059635D501A9FC2D5CCFA072605568 : high : Memory Leak : controlflow ]
#
#     sys/SYS_put_blob.c(110) : Branch taken: (strncmp(url, "http://", strlen("http://")) == 0)
#     sys/SYS_put_blob.c(112) : Branch not taken: (req != NULL)
#     sys/SYS_put_blob.c(122) : start -> allocated : urldup = strdup(...)
#     sys/SYS_put_blob.c(122) : allocated -> allocated : urldup refers to dynamically allocated memory
#     sys/SYS_put_blob.c(122) : Branch not taken: (urldup != NULL)
#     sys/SYS_put_blob.c(127) : Branch not taken: (data != NULL)
#     sys/SYS_put_blob.c(132) : allocated -> allocated : urldup refers to dynamically allocated memory
#     sys/SYS_put_blob.c(149) : Branch taken: (result == 0)
#     sys/SYS_put_blob.c(150) : allocated -> allocated : return
#     sys/SYS_put_blob.c(150) : allocated -> allocated : urldup no longer refers to dynamically allocated memory
#     sys/SYS_put_blob.c(150) : allocated -> allocated : <AnonymousObject>.url no longer refers to dynamically allocated memory
#     sys/SYS_put_blob.c(150) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
EA059635D501A9FC2D5CCFA072605568

# [C085398F6E69E7A9653341A2EFBE316C : high : Memory Leak : controlflow ]
#
#     sys/SYS_put_blob_mstp.c(87) : Branch not taken: (req != 0)
#     sys/SYS_put_blob_mstp.c(92) : start -> allocated : filenamedup = strdup(...)
#     sys/SYS_put_blob_mstp.c(92) : allocated -> allocated : filenamedup refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(92) : Branch not taken: (filenamedup != NULL)
#     sys/SYS_put_blob_mstp.c(97) : Branch not taken: (storagenamedup != NULL)
#     sys/SYS_put_blob_mstp.c(102) : allocated -> allocated : filenamedup refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(107) : Branch not taken: (data != NULL)
#     sys/SYS_put_blob_mstp.c(112) : allocated -> allocated : filenamedup refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(130) : Branch taken: (result == 0)
#     sys/SYS_put_blob_mstp.c(131) : allocated -> allocated : return
#     sys/SYS_put_blob_mstp.c(131) : allocated -> allocated : filenamedup no longer refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(131) : allocated -> allocated : <AnonymousObject>.filename no longer refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(131) : allocated -> allocated : <AnonymousObject>.filename no longer refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(131) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
C085398F6E69E7A9653341A2EFBE316C

# [8DD69C7BEE8DA8B456A48885F6E65603 : high : Memory Leak : controlflow ]
#
#     sys/SYS_put_blob_mstp.c(87) : Branch not taken: (req != 0)
#     sys/SYS_put_blob_mstp.c(92) : Branch not taken: (filenamedup != NULL)
#     sys/SYS_put_blob_mstp.c(97) : start -> allocated : storagenamedup = strdup(...)
#     sys/SYS_put_blob_mstp.c(97) : allocated -> allocated : storagenamedup refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(97) : Branch not taken: (storagenamedup != NULL)
#     sys/SYS_put_blob_mstp.c(102) : allocated -> allocated : storagenamedup refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(107) : Branch not taken: (data != NULL)
#     sys/SYS_put_blob_mstp.c(112) : allocated -> allocated : storagenamedup refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(130) : Branch taken: (result == 0)
#     sys/SYS_put_blob_mstp.c(131) : allocated -> allocated : return
#     sys/SYS_put_blob_mstp.c(131) : allocated -> allocated : storagenamedup no longer refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(131) : allocated -> allocated : <AnonymousObject>.storage_name no longer refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(131) : allocated -> allocated : <AnonymousObject>.storage_name no longer refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(131) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
8DD69C7BEE8DA8B456A48885F6E65603

# [95687588EC827BE03A380FE00DA785C9 : high : Type Mismatch : Signed to Unsigned : structural ]
#     sys/SYS_put_blob_mstp.c(72)
#     Function: io_cb [sys/SYS_put_blob_mstp.c(61)]
95687588EC827BE03A380FE00DA785C9

# False positive
# data is freed in blob_cb
#
# [EE06A6D14E606A702E4F8A8C7EBEF7B0 : high : Memory Leak : controlflow ]
#
#     sys/SYS_put_blob.c(110) : Branch taken: (strncmp(url, "http://", strlen("http://")) == 0)
#     sys/SYS_put_blob.c(112) : Branch not taken: (req != NULL)
#     sys/SYS_put_blob.c(122) : Branch not taken: (urldup != NULL)
#     sys/SYS_put_blob.c(127) : start -> allocated : data = malloc(...)
#     sys/SYS_put_blob.c(127) : allocated -> allocated : data refers to dynamically allocated memory
#     sys/SYS_put_blob.c(127) : Branch not taken: (data != NULL)
#     sys/SYS_put_blob.c(145) : allocated -> allocated : EVP_impl_blobOperation(?, ?, ?, ?, ?, ?, ?, data)
#         sdk.c(1623) : allocated -> allocated : userData refers to dynamically allocated memory
#         sdk.c(1629) : Branch taken: (check_blob_type(type) != 0)
#         sdk.c(1631) : goto
#     sys/SYS_put_blob.c(149) : Branch taken: (result == 0)
#     sys/SYS_put_blob.c(150) : allocated -> allocated : return
#     sys/SYS_put_blob.c(150) : allocated -> allocated : data no longer refers to dynamically allocated memory
#     sys/SYS_put_blob.c(150) : allocated -> leak : data end scope : Memory leaked
EE06A6D14E606A702E4F8A8C7EBEF7B0

# False positive
# req is freed in blob_cb
#
# [EE06A6D14E606A702E4F8A8C7EBEF7B1 : high : Memory Leak : controlflow ]
#
#     sys/SYS_put_blob.c(110) : Branch taken: (strncmp(url, "http://", strlen("http://")) == 0)
#     sys/SYS_put_blob.c(112) : start -> allocated : req = create_request(...)
#         sys/SYS_put_blob.c(39) : start -> allocated : ret = EVP_BlobRequestHttpExt_initialize()
#             sdk_common.c(143) : start -> allocated : request = malloc(...)
#             sdk_common.c(143) : allocated -> allocated : request refers to dynamically allocated memory
#             sdk_common.c(145) : Branch taken: (request != 0)
#             sdk_common.c(150) : allocated -> allocated : return
#         sys/SYS_put_blob.c(39) : allocated -> allocated : ret refers to dynamically allocated memory
#         sys/SYS_put_blob.c(39) : Branch not taken: (ret != NULL)
#         sys/SYS_put_blob.c(43) : Branch not taken: (sys_add_headers(ret, headers) == 0)
#         sys/SYS_put_blob.c(47) : Branch not taken: (EVP_BlobRequestHttpExt_setUrl(ret, url) == 0)
#         sys/SYS_put_blob.c(51) : allocated -> allocated : return
#     sys/SYS_put_blob.c(112) : allocated -> allocated : req refers to dynamically allocated memory
#     sys/SYS_put_blob.c(112) : Branch not taken: (req != NULL)
#     sys/SYS_put_blob.c(122) : Branch not taken: (urldup != NULL)
#     sys/SYS_put_blob.c(127) : Branch not taken: (data != NULL)
#     sys/SYS_put_blob.c(132) : allocated -> allocated : req refers to dynamically allocated memory
#     sys/SYS_put_blob.c(145) : allocated -> allocated : EVP_impl_blobOperation(?, ?, ?, ?, req, ?, ?, ?)
#         sdk.c(1621) : allocated -> allocated : request refers to dynamically allocated memory
#         sdk.c(1629) : Branch taken: (check_blob_type(type) != 0)
#         sdk.c(1631) : goto
#     sys/SYS_put_blob.c(149) : Branch taken: (result == 0)
#     sys/SYS_put_blob.c(150) : allocated -> allocated : return
#     sys/SYS_put_blob.c(150) : allocated -> allocated : req no longer refers to dynamically allocated memory
#     sys/SYS_put_blob.c(150) : allocated -> allocated : <AnonymousObject>.req no longer refers to dynamically allocated memory
#     sys/SYS_put_blob.c(150) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
EE06A6D14E606A702E4F8A8C7EBEF7B1

# False positive
# data is freed in blob_cb_mstp
#
# [02DEF264481763E639D4071FE6AAC3B6 : high : Memory Leak : controlflow ]
#
#     sys/SYS_put_blob_mstp.c(87) : Branch not taken: (req != 0)
#     sys/SYS_put_blob_mstp.c(92) : Branch not taken: (filenamedup != NULL)
#     sys/SYS_put_blob_mstp.c(97) : Branch not taken: (storagenamedup != NULL)
#     sys/SYS_put_blob_mstp.c(107) : start -> allocated : data = malloc(...)
#     sys/SYS_put_blob_mstp.c(107) : allocated -> allocated : data refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(107) : Branch not taken: (data != NULL)
#     sys/SYS_put_blob_mstp.c(126) : allocated -> allocated : EVP_impl_blobOperation(?, ?, ?, ?, ?, ?, ?, data)
#         sdk.c(1623) : allocated -> allocated : userData refers to dynamically allocated memory
#         sdk.c(1629) : Branch taken: (check_blob_type(type) != 0)
#         sdk.c(1631) : goto
#     sys/SYS_put_blob_mstp.c(130) : Branch taken: (result == 0)
#     sys/SYS_put_blob_mstp.c(131) : allocated -> allocated : return
#     sys/SYS_put_blob_mstp.c(131) : allocated -> allocated : data no longer refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(131) : allocated -> leak : data end scope : Memory leaked
02DEF264481763E639D4071FE6AAC3B6

# False positive
# req is freed in blob_cb_mstp
#
# [02DEF264481763E639D4071FE6AAC3B7 : high : Memory Leak : controlflow ]
#
#     sys/SYS_put_blob_mstp.c(85) : start -> allocated : req = malloc(...)
#     sys/SYS_put_blob_mstp.c(85) : allocated -> allocated : req refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(87) : Branch not taken: (req != 0)
#     sys/SYS_put_blob_mstp.c(92) : Branch not taken: (filenamedup != NULL)
#     sys/SYS_put_blob_mstp.c(97) : Branch not taken: (storagenamedup != NULL)
#     sys/SYS_put_blob_mstp.c(107) : Branch not taken: (data != NULL)
#     sys/SYS_put_blob_mstp.c(112) : allocated -> allocated : req refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(126) : allocated -> allocated : EVP_impl_blobOperation(?, ?, ?, ?, req, ?, ?, ?)
#         sdk.c(1621) : allocated -> allocated : request refers to dynamically allocated memory
#         sdk.c(1629) : Branch taken: (check_blob_type(type) != 0)
#         sdk.c(1631) : goto
#     sys/SYS_put_blob_mstp.c(130) : Branch taken: (result == 0)
#     sys/SYS_put_blob_mstp.c(131) : allocated -> allocated : return
#     sys/SYS_put_blob_mstp.c(131) : allocated -> allocated : req no longer refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(131) : allocated -> allocated : <AnonymousObject>.req no longer refers to dynamically allocated memory
#     sys/SYS_put_blob_mstp.c(131) : allocated -> leak : <AnonymousObject> end scope : Memory leaked
02DEF264481763E639D4071FE6AAC3B7

# False positive
# Foritfy doesn't understand that the enum are unsigned
#
#[95687588EC827BE03A380FE00DA785C8 : high : Type Mismatch : Signed to Unsigned : structural ]
#    sys/SYS_put_blob.c(154)
#    Function: io_cb [sys/SYS_put_blob.c(141)]
95687588EC827BE03A380FE00DA785C8
